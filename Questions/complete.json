[
    {
        "question": "Which of the following are legal entry point methods that can be run from the command line? (Choose all that apply.)",
        "options": [
            "A. private static void main(String[] args)",
            "B. public static final main(String[] args)",
            "C. public void main(String[] args)",
            "D. public static final void main(String[] args)",
            "E. public static void main(String[] args)",
            "F. public static main(String[] args)"
        ],
        "answer": [
            "D",
            "E"
        ],
        "explanation": "Option E is the canonical main() method signature. You need to memorize it. Option D is an alternate form with the redundant final. Option A is incorrect because the main() method must be public. Options B and F are incorrect because the main() method must have a void return type. Option C is incorrect because the main() method must be static."
    },
    {
        "question": "Which answer options represent the order in which the following statements can be assembled into a program that will compile successfully? (Choose all that apply.)",
        "statements": [
            "X: class Rabbit {}",
            "Y: import java.util.*;",
            "Z: package animals;"
        ],
        "options": [
            "A. X, Y, Z",
            "B. Y, Z, X",
            "C. Z, Y, X",
            "D. Y, X",
            "E. Z, X",
            "F. X, Z",
            "G. None of the above"
        ],
        "answer": [
            "C",
            "D",
            "E"
        ],
        "explanation": "The package and import statements are both optional. If both are present, the order must be package, then import, and then class. Option A is incorrect because class is before package and import. Option B is incorrect because import is before package. Option F is incorrect because class is before package."
    },
    {
        "question": "Which of the following are true? (Choose all that apply.)",
        "code": "public class Bunny {\npublic static void main(String[] x) {\nBunny bun = new Bunny();\n} }",
        "options": [
            "A. Bunny is a class.",
            "B. bun is a class.",
            "C. main is a class.",
            "D. Bunny is a reference to an object.",
            "E. bun is a reference to an object.",
            "F. main is a reference to an object.",
            "G. The main() method doesn’t run because the parameter name is incorrect."
        ],
        "answer": [
            "A",
            "E"
        ],
        "explanation": "Bunny is a class, which can be seen from the declaration: public class Bunny. The variable bun is a reference to an object. The method main() is the standard entry point to a program. Option G is incorrect because the parameter type matters, not the parameter name."
    },
    {
        "question": "Which of the following are valid Java identifiers? (Choose all that apply.)",
        "options": [
            "A. _",
            "B. _helloWorld$",
            "C. true",
            "D. java.lang",
            "E. Public",
            "F. 1980_s",
            "G. _Q2_"
        ],
        "answer": [
            "B",
            "E",
            "G"
        ],
        "explanation": "Option A is invalid because a single underscore is not allowed. Option C is not a valid identifier because true is a Java reserved word. Option D is not valid because a period (.) is not allowed in identifiers. Option F is not valid because the first character is not a letter, dollar sign ($), or underscore (_). Options B, E, and G are valid because they contain only valid characters."
    },
    {
        "question": "Which statements about the following program are correct? (Choose all that apply.)",
        "code": "2: public class Bear {\n3:\nprivate Bear pandaBear;\n4:\nprivate void roar(Bear b) {\n5:\nSystem.out.println(\"Roar!\");\n6:\npandaBear = b;\n7:\n}\n8:\npublic static void main(String[] args) {\n9:\nBear brownBear = new Bear();\n10:\nBear polarBear = new Bear();\n11:\nbrownBear.roar(polarBear);\n12:\npolarBear = null;\n13:\nbrownBear = null;\n14:\nSystem.gc(); } }",
        "options": [
            "A. The object created on line 9 is first eligible for garbage collection after line 13.",
            "B. The object created on line 9 is first eligible for garbage collection after line 14.",
            "C. The object created on line 10 is first eligible for garbage collection after line 12.",
            "D. The object created on line 10 is first eligible for garbage collection after line 13.",
            "E. Garbage collection is guaranteed to run.",
            "F. Garbage collection might or might not run.",
            "G. The code does not compile."
        ],
        "answer": [
            "A",
            "D",
            "F"
        ],
        "explanation": "Garbage collection is never guaranteed to run, making option F correct and option E incorrect. Next, the class compiles and runs without issue, so option G is incorrect. The Bear object created on line 9 is accessible until line 13 via the brownBear reference variable, which is option A. The Bear object created on line 10 is accessible via both the polarBear reference and the brownBear.pandaBear reference. After line 12, the object is still accessible via brownBear.pandaBear. After line 13, though, it is no longer accessible since brownBear is no longer accessible, which makes option D the final correct answer."
    },
    {
        "question": "Assuming the following class compiles, how many variables defined in the class or method are in scope on the line marked on line 14?",
        "code": "1: public class Camel {\n2:\n{ int hairs = 3_000_0; }\n3:\nlong water, air=2;\n4:\nboolean twoHumps = true;\n5:\npublic void spit(float distance) {\n6:\nvar path = \"\";\n7:\n{ double teeth = 32 + distance++; }\n8:\nwhile(water> 0) {\n9:\nint age = twoHumps ? 1 : 2;\n10:\nshort i=-1;\n11:\nfor(i=0; i<10; i++) {\n12:\nvar Private = 2;\n13:\n}\n14:\n// SCOPE\n15:\n}\n16:\n}\n17: }",
        "options": [
            "A. 2",
            "B. 3",
            "C. 4",
            "D. 5",
            "E. 6",
            "F. 7",
            "G. None of the above"
        ],
        "answer": [
            "F"
        ],
        "explanation": "To solve this problem, you need to trace the braces ({}) and see when variables go in and out of scope. The variables on lines 2 and 7 are only in scope for a single line block. The variable on line 12 is only in scope for the for loop. None of these is in scope on line 14. By contrast, the three instance variables on lines 3 and 4 are available in all instance methods. Additionally, the variables on lines 6, 9, and 10 are available since the method and while loop are still in scope. This is a total of 7 variables, which is option F."
    },
    {
        "question": "Which are true about this code? (Choose all that apply.)",
        "code": "public class KitchenSink {\nprivate int numForks;\npublic static void main(String[] args) {\nint numKnives;\nSystem.out.print(\"\"\"\n\"# forks = \" + numForks +\n\" # knives = \" + numKnives +\n# cups = 0\"\n\"\"\");\n}\n}",
        "options": [
            "A. The output includes # forks = 0.",
            "B. The output includes # knives = 0.",
            "C. The output includes # cups = 0.",
            "D. The output includes a blank line.",
            "E. The output includes one or more lines that begin with whitespace.",
            "F. The code does not compile."
        ],
        "answer": [
            "C",
            "E"
        ],
        "explanation": "The first thing to recognize is that this is a text block and the code inside the \"\"\" is just text. Options A and B are incorrect because the numForks and numKnives variables are not used. This is convenient since numKnives is not initialized and would not compile if it were referenced. Option C is correct as it is matching text. Option D is incorrect because the text block does not have a trailing blank line. Finally, option E is also an answer since \" # knives is indented."
    },
    {
        "question": "Which of the following code snippets about var compile without issue when used in a method? (Choose all that apply.)",
        "options": [
            "A. var spring = null;",
            "B. var fall = \"leaves\";",
            "C. var evening = 2; evening = null;",
            "D. var night = Integer.valueOf(3);",
            "E. var day = 1/0;",
            "F. var winter = 12, cold;",
            "G. var fall = 2, autumn = 2;",
            "H. var morning = \"\"; morning = null;"
        ],
        "answer": [
            "B",
            "D",
            "E",
            "H"
        ],
        "explanation": "A var cannot be initialized with a null value without a type, but it can be assigned a null value later if the underlying type is not a primitive. For these reasons, option H is correct, but options A and C are incorrect. Options B and D are correct as the underlying types are String and Integer, respectively. Option E is correct as this is a valid numeric expression. You might know that dividing by zero produces a runtime exception, but the question was only about whether the code compiled. Finally, options F and G are incorrect as var cannot be used in a multiple-variable assignment."
    },
    {
        "question": "Which of the following is correct?",
        "options": [
            "A. An instance variable of type float defaults to 0.",
            "B. An instance variable of type char defaults to null.",
            "C. A local variable of type double defaults to 0.0.",
            "D. A local variable of type int defaults to null.",
            "E. A class variable of type String defaults to null.",
            "F. A class variable of type String defaults to the empty string \"\".",
            "G. None of the above."
        ],
        "answer": [
            "E"
        ],
        "explanation": "Options C and D are incorrect because local variables don’t have default values. Option A is incorrect because float should have a decimal point. Option B is incorrect because primitives do not default to null. Option E is correct and option F incorrect because reference types in class variables default to null."
    },
    {
        "question": "Which of the following expressions, when inserted independently into the blank line, allow the code to compile? (Choose all that apply.)",
        "code": "public void printMagicData() {\nvar magic = ;\nSystem.out.println(magic);\n}",
        "options": [
            "A. 3_1",
            "B. 1_329_.0",
            "C. 3_13.0_",
            "D. 5_291._2",
            "E. 2_234.0_0",
            "F. 9___6",
            "G. _1_3_5_0"
        ],
        "answer": [
            "A",
            "E",
            "F"
        ],
        "explanation": "An underscore (_) can be placed in any numeric literal, as long as it is not at the beginning, at the end, or next to a decimal point (.). Underscores can even be placed next to each other. For these reasons, options A, E, and F are correct. Options B and D are incorrect as the underscore (_) is next to a decimal point (.). Options C and G are incorrect because an underscore (_) cannot be placed at the beginning or end of the literal."
    },
    {
        "question": "Given the following two class files, what is the maximum number of imports that can be removed and have the code still compile?",
        "code": "// Water.java\npackage aquarium;\npublic class Water { }\n// Tank.java\npackage aquarium;\nimport java.lang.*;\nimport java.lang.System;\nimport aquarium.Water;\nimport aquarium.*;\npublic class Tank {\npublic void print(Water water) {\nSystem.out.println(water); } }",
        "options": [
            "A. 0",
            "B. 1",
            "C. 2",
            "D. 3",
            "E. 4",
            "F. Does not compile"
        ],
        "answer": [
            "E"
        ],
        "explanation": "The first two imports can be removed because java.lang is automatically imported. The following two imports can be removed because Tank and Water are in the same package, making the correct option E. If Tank and Water were in different packages, exactly one of these two imports could be removed. In that case, the answer would be option D."
    },
    {
        "question": "Which statements about the following class are correct? (Choose all that apply.)",
        "code": "1: public class ClownFish {\n2:\nint gills = 0, double weight=2;\n3:\n{ int fins = gills; }\n4:\nvoid print(int length = 3) {\n5:\nSystem.out.println(gills);\n6:\nSystem.out.println(weight);\n7:\nSystem.out.println(fins);\n8:\nSystem.out.println(length);\n9: } }",
        "options": [
            "A. Line 2 generates a compiler error.",
            "B. Line 3 generates a compiler error.",
            "C. Line 4 generates a compiler error.",
            "D. Line 7 generates a compiler error.",
            "E. The code prints 0.",
            "F. The code prints 2.0.",
            "G. The code prints 2.",
            "H. The code prints 3."
        ],
        "answer": [
            "A",
            "C",
            "D"
        ],
        "explanation": "Line 2 does not compile as only one type should be specified, making option A correct. Line 3 compiles without issue as it declares a local variable inside an instance initializer that is never used. Line 4 does not compile because Java does not support setting default method parameter values, making option C correct. Finally, line 7 does not compile because fins is in scope and accessible only inside the instance initializer on line 3, making option D correct."
    },
    {
        "question": "Given the following classes, which of the following snippets can independently be inserted in place of INSERT IMPORTS HERE and have the code compile? (Choose all that apply.)",
        "code": "package aquarium;\npublic class Water {\nboolean salty = false;\n}\npackage aquarium.jellies;\npublic class Water {\nboolean salty = true;\n}\npackage employee;\nINSERT IMPORTS HERE\npublic class WaterFiller {Water water;\n}",
        "options": [
            "A. import aquarium.*;",
            "B. import aquarium.Water;",
            "C. import aquarium.jellies.*;",
            "D. import aquarium.*;",
            "E. import aquarium.jellies.Water;",
            "F. import aquarium.*;",
            "G. import aquarium.jellies.*;",
            "H. import aquarium.Water;",
            "I. import aquarium.jellies.Water;",
            "J. None of the above"
        ],
        "answer": [
            "A",
            "C",
            "D",
            "F",
            "G"
        ],
        "explanation": "Option A is correct because it imports all the classes in the aquarium package including aquarium.Water. Options B and C are correct because they import Water by class name. Since importing by class name takes precedence over wildcards, these compile. Option D is incorrect because Java doesn’t know which of the two wildcard Water classes to use. Option E is incorrect because you cannot specify the same class name in two imports."
    },
    {
        "question": "Which of the following statements about the code snippet are true? (Choose all that apply.)",
        "code": "3: short numPets = 5L;\n4: int numGrains = 2.0;\n5: String name = \"Scruffy\";\n6: int d = numPets.length();\n7: int e = numGrains.length;\n8: int f = name.length();",
        "options": [
            "A. Line 3 generates a compiler error.",
            "B. Line 4 generates a compiler error.",
            "C. Line 5 generates a compiler error.",
            "D. Line 6 generates a compiler error.",
            "E. Line 7 generates a compiler error.",
            "F. Line 8 generates a compiler error."
        ],
        "answer": [
            "A",
            "B",
            "D",
            "E"
        ],
        "explanation": "Line 3 does not compile because the L suffix makes the literal value a long, which cannot be stored inside a short directly, making option A correct. Line 4 does not compile because int is an integral type, but 2.0 is a double literal value, making option B correct. Line 5 compiles without issue. Lines 6 and 7 do not compile because numPets and numGrains are both primitives, and you can call methods only on reference types, not primitive values, making options D and E correct, respectively. Finally, line 8 compiles because there is a length() method defined on String."
    },
    {
        "question": "Which of the following statements about garbage collection are correct? (Choose all that apply.)",
        "options": [
            "A. Calling System.gc() is guaranteed to free up memory by destroying objects eligible for garbage collection.",
            "B. Garbage collection runs on a set schedule.",
            "C. Garbage collection allows the JVM to reclaim memory for other objects.",
            "D. Garbage collection runs when your program has used up half the available memory.",
            "E. An object may be eligible for garbage collection but never removed from the heap.",
            "F. An object is eligible for garbage collection once no references to it are accessible in the program.",
            "G. Marking a variable final means its associated object will never be garbage collected."
        ],
        "answer": [
            "C",
            "E",
            "F"
        ],
        "explanation": "In Java, there are no guarantees about when garbage collection will run. The JVM is free to ignore calls to System.gc(). For this reason, options A, B, and D are incorrect. Option C is correct as the purpose of garbage collection is to reclaim used memory. Option E is also correct that an object may never be garbage collected, such as if the program ends before garbage collection runs. Option F is correct and is the primary means by which garbage collection algorithms determine whether an object is eligible for garbage collection. Finally, option G is incorrect as marking a variable final means it is constant within its own scope. For example, a local variable marked final will be eligible for garbage collection after the method ends, assuming there are no other references to the object that exist outside the method."
    },
    {
        "question": "Which are true about this code? (Choose all that apply.)",
        "code": "var blocky = \"\"\"\nsquirrel \\s\npigeon\n\\\ntermite\"\"\";\nSystem.out.print(blocky);",
        "options": [
            "A. It outputs two lines.",
            "B. It outputs three lines.",
            "C. It outputs four lines.",
            "D. There is one line with trailing whitespace.",
            "E. There are two lines with trailing whitespace.",
            "F. If we indented each line five characters, it would change the output."
        ],
        "answer": [
            "A",
            "D"
        ],
        "explanation": "Option A is correct. There are two lines. One starts with squirrel, and the other starts with pigeon. Remember that a backslash means to skip the line break. Option D is also correct as \\s means to keep whitespace. In a text block, incidental indentation is ignored, making option F incorrect."
    },
    {
        "question": "What lines are printed by the following program? (Choose all that apply.)",
        "code": "1: public class WaterBottle {\n2:\nprivate String brand;\n3:\nprivate boolean empty;\n4:\npublic static float code;\n5:\npublic static void main(String[] args) {\n6:\nWaterBottle wb = new WaterBottle();\n7:\nSystem.out.println(\"Empty = \" + wb.empty);\n8:\nSystem.out.println(\"Brand = \" + wb.brand);\n9:\nSystem.out.println(\"Code = \" + code);\n10: } }",
        "options": [
            "A. Line 8 generates a compiler error.",
            "B. Line 9 generates a compiler error.",
            "C. Empty =",
            "D. Empty = false",
            "E. Brand =",
            "F. Brand = null",
            "G. Code = 0.0",
            "H. Code = 0f"
        ],
        "answer": [
            "D",
            "F",
            "G"
        ],
        "explanation": "The code compiles and runs without issue, so options A and B are incorrect. A boolean field initializes to false, making option D correct with Empty = false being printed. Object references initialize to null, not the empty String, so option F is correct with Brand = null being printed. Finally, the default value of floating-point numbers is 0.0. Although float values can be declared with an f suffix, they are not printed with an f suffix. For these reasons, option G is correct and Code = 0.0 is printed."
    },
    {
        "question": "Which of the following statements about var are true? (Choose all that apply.)",
        "options": [
            "A. A var can be used as a constructor parameter.",
            "B. The type of a var is known at compile time.",
            "C. A var cannot be used as an instance variable.",
            "D. A var can be used in a multiple variable assignment statement.",
            "E. The value of a var cannot change at runtime.",
            "F. The type of a var cannot change at runtime.",
            "G. The word var is a reserved word in Java."
        ],
        "answer": [
            "B",
            "C",
            "F"
        ],
        "explanation": "A var cannot be used for a constructor or method parameter or for an instance or class variable, making option A incorrect and option C correct. The type of a var is known at compile time, and the type cannot be changed at runtime, although its value can change at runtime. For these reasons, options B and F are correct, and option E is incorrect. Option D is incorrect, as var is not permitted in multiple-variable declarations. Finally, option G is incorrect, as var is not a reserved word in Java."
    },
    {
        "question": "Which are true about the following code? (Choose all that apply.)",
        "code": "var num1 = Integer.parseInt(\"11\");\nvar num2 = Integer.valueOf(\"B\", 16);\nSystem.out.println(Integer.max(num1, num2));",
        "options": [
            "A. The output is 11.",
            "B. The output is B.",
            "C. The code does not compile.",
            "D. num1 is a primitive.",
            "E. num2 is a primitive.",
            "F. A NumberFormatException is thrown."
        ],
        "answer": [
            "A",
            "D"
        ],
        "explanation": "The first two lines provide a way to convert a String into a number. The first is a int primitive, and the second is a Integer reference object, making option D one of the answers. Remember that B is 11 in base 16. The code is correct, and the maximum is 11, which is option A."
    },
    {
        "question": "Which statement about the following class is correct?",
        "code": "1:\n2:\npublic class PoliceBox {\nString color;3:\nlong age;\n4:\npublic void PoliceBox() {\n5:\ncolor = \"blue\";\n6:\nage = 1200;\n7:\n}\n8:\npublic static void main(String []time) {\n9:\nvar p = new PoliceBox();\n10:\nvar q = new PoliceBox();\n11:\np.color = \"green\";\n12:\np.age = 1400;\n13:\np = q;\n14:\nSystem.out.println(\"Q1=\"+q.color);\n15:\nSystem.out.println(\"Q2=\"+q.age);\n16:\nSystem.out.println(\"P1=\"+p.color);\n17:\nSystem.out.println(\"P2=\"+p.age);\n18: } }",
        "options": [
            "A. It prints Q1=blue.",
            "B. It prints Q2=1200.",
            "C. It prints P1=null.",
            "D. It prints P2=1400.",
            "E. Line 4 does not compile.",
            "F. Line 12 does not compile.",
            "G. Line 13 does not compile.",
            "H. None of the above."
        ],
        "answer": [
            "C"
        ],
        "explanation": "The key thing to notice is that line 4 does not define a constructor but instead a method named PoliceBox(), since it has a return type of void. This method is never executed during the program run, and color and age are assigned the default values null and 0L, respectively. Lines 11 and 12 change the values for an object associated with p, but then, on line 13, the p variable is changed to point to the object associated with q, which still has the default values. For this reason, the program prints Q1=null, Q2=0, P1=null, and P2=0, making option C the only correct answer."
    },
    {
        "question": "What is the output of executing the following class?",
        "code": "1: public class Salmon {\n2:\nint count;\n3:\n{ System.out.print(count+\"-\"); }\n4:\n{ count++; }\n5:\npublic Salmon() {\n6:\ncount = 4;\n7:\nSystem.out.print(2+\"-\");\n8:\n}\n9:\npublic static void main(String[] args) {\n10:\nSystem.out.print(7+\"-\");\n11:\nvar s = new Salmon();\n12:\nSystem.out.print(s.count+\"-\"); } }",
        "options": [
            "A. 7-0-2-1-",
            "B. 7-0-1-",
            "C. 0-7-2-1-",
            "D. 7-0-2-4-",
            "E. 0-7-1-",
            "F. The class does not compile because of line 3.",
            "G. The class does not compile because of line 4.",
            "H. None of the above."
        ],
        "answer": [
            "D"
        ],
        "explanation": "We start with the main() method, which prints 7- on line 10. Next, a new Salmon instance is created on line 11. This causes the two instance initializers on lines 3 and 4 to be executed in order. The default value of an instance variable of type int is 0, so 0- is printed next, and count is assigned a value of 1. Next, the constructor is called. This assigns a value of 4 to count and prints 2-. Finally, line 12 prints 4-, since that is the value of count. Putting it all together, we have 7-0-2-4-, making option D the correct answer."
    },
    {
        "question": "Given the following class, which of the following lines of code can independently replace INSERT CODE HERE to make the code compile? (Choose all that apply.)",
        "code": "public class Price {\npublic void admission() {\nINSERT CODE HERE\nSystem.out.print(amount);\n} }",
        "options": [
            "A. int Amount = 0b11;",
            "B. int amount = 9L;",
            "C. int amount = 0xE;",
            "D. int amount = 1_2.0;",
            "E. double amount = 1_0_.0;",
            "F. int amount = 0b101;",
            "G. double amount = 9_2.1_2;",
            "H. double amount = 1_2_.0_0;"
        ],
        "answer": [
            "C",
            "F",
            "G"
        ],
        "explanation": "First, 0b is the prefix for a binary value, and 0x is the prefix for a hexadecimal value. These values can be assigned to many primitive types, including int and double, making options C and F correct. Option A is incorrect because naming the variable Amount will cause the System.out.print(amount) call on the next line to not compile. Option B is incorrect because 9L is a long value. If the type was changed to long amount = 9L, then it would compile. Option D is incorrect because 1_2.0 is a double value. If the type was changed to double amount = 1_2.0, then it would compile. Options E and H are incorrect because the underscore (_) appears next to the decimal point (.), which is not allowed. Finally, option G is correct, and the underscore and assignment usage is valid."
    },
    {
        "question": "Which statements about the following class are true? (Choose all that apply.)",
        "code": "1: public class River {\n2:\nint Depth = 1;\n3:\nfloat temp = 50.0;\n4:\npublic void flow() {\n5:\nfor (int i = 0; i < 1; i++) {\n6:\nint depth = 2;\n7:\ndepth++;\n8:\ntemp--;\n9:\n}\n10:\nSystem.out.println(depth);\n11:\nSystem.out.println(temp); }\n12:\npublic static void main(String… s) {\n13:\nnew River().flow();\n14: } }",
        "options": [
            "A. Line 3 generates a compiler error.",
            "B. Line 6 generates a compiler error.",
            "C. Line 7 generates a compiler error.",
            "D. Line 10 generates a compiler error.",
            "E. The program prints 3 on line 10.",
            "F. The program prints 4 on line 10.",
            "G. The program prints 50.0 on line 11.",
            "H. The program prints 49.0 on line 11."
        ],
        "answer": [
            "A",
            "D"
        ],
        "explanation": "The first compiler error is on line 3. The variable temp is declared as a float, but the assigned value is 50.0, which is a double without the F/f postfix. Since a double doesn’t fit inside a float, line 3 does not compile. Next, depth is declared inside the for loop and has scope only inside this loop. Therefore, reading the value on line 10 triggers a compiler error. For these reasons, options A and D are the correct answers."
    },
    {
        "question": "Which of the following Java operators can be used with boolean variables? (Choose all that apply.)",
        "options": [
            "A. ==",
            "B. +",
            "C. --",
            "D. !",
            "E. %",
            "F. -",
            "G. Cast with (boolean)"
        ],
        "answer": [
            "A",
            "D"
        ],
        "explanation": "The == and ! operators can be used with boolean variables. The +, --, %, and - operators are not applicable to boolean variables. Casting with (boolean) is not a valid operation."
    },
    {
        "question": "What data type (or types) will allow the following code snippet to compile? (Choose all that apply.)",
        "code": "byte apples = 5;\nshort oranges = 10;\n____ bananas = apples + oranges;",
        "options": [
            "A. int",
            "B. long",
            "C. boolean",
            "D. double",
            "E. short",
            "F. byte"
        ],
        "answer": [
            "A",
            "B",
            "D"
        ],
        "explanation": "The result of adding a byte and a short is an int, so the variable bananas must be of type int, long, or double to compile. The types boolean, short, and byte are not valid."
    },
    {
        "question": "What change, when applied independently, would allow the following code snippet to compile? (Choose all that apply.)",
        "code": "3: long ear = 10;\n4: int hearing = 2 * ear;",
        "options": [
            "A. No change; it compiles as is.",
            "B. Cast ear on line 4 to int.",
            "C. Change the data type of ear on line 3 to short.",
            "D. Cast 2 * ear on line 4 to int.",
            "E. Change the data type of hearing on line 4 to short.",
            "F. Change the data type of hearing on line 4 to long."
        ],
        "answer": [
            "B",
            "D",
            "F"
        ],
        "explanation": "The code does not compile as is because the result of 2 * ear is a long, which cannot be assigned to an int without casting. Casting ear or 2 * ear to int, or changing the data type of hearing to long, will allow the code to compile."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "3: boolean canine = true, wolf = true;\n4: int teeth = 20;\n5: canine = (teeth != 10) ^ (wolf=false);\n6: System.out.println(canine+\", \"+teeth+\", \"+wolf);",
        "options": [
            "A. true, 20, true",
            "B. true, 20, false",
            "C. false, 10, true",
            "D. false, 20, false",
            "E. The code will not compile because of line 5.",
            "F. None of the above."
        ],
        "answer": [
            "D"
        ],
        "explanation": "The expression (teeth != 10) evaluates to true, and (wolf=false) evaluates to false. The ^ operator is the logical XOR, so true ^ false is true. Therefore, canine is set to true. The output is false, 20, false."
    },
    {
        "question": "Which of the following operators are ranked in increasing or the same order of precedence? Assume the + operator is binary addition, not the unary form. (Choose all that apply.)",
        "options": [
            "A. +, *, %, --",
            "B. ++, (int), *",
            "C. =, ==, !",
            "D. (short), =, !, *",
            "E. *, /, %, +, ==",
            "F. !, ||, &",
            "G. ^, +, =, +="
        ],
        "answer": [
            "B",
            "E",
            "F"
        ],
        "explanation": "The operators in option B (++ has higher precedence than (int), which has higher precedence than *), option E (*, /, and % have the same precedence, which is higher than +, which is higher than ==), and option F (! has higher precedence than ||, which has higher precedence than &)."
    },
    {
        "question": "What is the output of the following program?",
        "code": "1: public class CandyCounter {\n2: static long addCandy(double fruit, float vegetables) {\n3: return (int)fruit+vegetables;\n4: }\n5: public static void main(String[] args) {\n6: System.out.print(addCandy(1.4, 2.4f) + \", \");\n7: System.out.print(addCandy(1.9, (float)4) + \", \");\n8: System.out.print(addCandy((long)(int)(short)2, (float)4));\n9: } }",
        "options": [
            "A. 4, 6, 6.0",
            "B. 3, 5, 6",
            "C. 3, 6, 6",
            "D. 4, 5, 6",
            "E. The code does not compile because of line 9.",
            "F. None of the above."
        ],
        "answer": [
            "D"
        ],
        "explanation": "The method addCandy casts the double fruit to an int and adds it to the float vegetables. The results are (int)1.4 + 2.4f = 1 + 2.4f = 3.4f, which is cast to long as 3, (int)1.9 + 4 = 1 + 4 = 5, and (int)2 + 4 = 2 + 4 = 6. Therefore, the output is 4, 5, 6."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "int ph = 7, vis = 2;\nboolean clear = vis > 1 & (vis < 9 || ph < 2);\nboolean safe = (vis > 2) && (ph++ > 1);\nboolean tasty = 7 <= --ph;\nSystem.out.println(clear + \"-\" + safe + \"-\" + tasty);",
        "options": [
            "A. true-true-true",
            "B. true-true-false",
            "C. true-false-true",
            "D. true-false-false",
            "E. false-true-true",
            "F. false-true-false",
            "G. false-false-true",
            "H. false-false-false"
        ],
        "answer": [
            "C"
        ],
        "explanation": "The expression vis > 1 & (vis < 9 || ph < 2) evaluates to true & (true || false) = true & true = true, so clear is true. The expression (vis > 2) && (ph++ > 1) evaluates to false && (7 > 1) = false, so safe is false. The expression 7 <= --ph evaluates to 7 <= 6, which is false, so tasty is false. Therefore, the output is true-false-true."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "4: int pig = (short)4;\n5: pig = pig++;\n6: long goat = (int)2;\n7: goat -= 1.0;\n8: System.out.print(pig + \" - \" + goat);",
        "options": [
            "A. 4 - 1",
            "B. 4 - 2",
            "C. 5 - 1",
            "D. 5 - 2",
            "E. The code does not compile due to line 7.",
            "F. None of the above."
        ],
        "answer": [
            "E"
        ],
        "explanation": "The code does not compile because of line 7. The expression goat -= 1.0 attempts to subtract a double from a long, which is not allowed without casting."
    },
    {
        "question": "What are the unique outputs of the following code snippet? (Choose all that apply.)",
        "code": "int a = 2, b = 4, c = 2;\nSystem.out.println(a > 2 ? --c : b++);\nSystem.out.println(b = (a != c ? a : b++));\nSystem.out.println(a > b ? b < c ? b : 2 : 1);",
        "options": [
            "A. 1",
            "B. 2",
            "C. 3",
            "D. 4",
            "E. 5",
            "F. 6",
            "G. The code does not compile."
        ],
        "answer": [
            "B",
            "D"
        ],
        "explanation": "The first expression (a > 2 ? --c : b++) evaluates to 2 > 2 ? --c : b++, which is false, so b++ is executed, and b is incremented to 5. The second expression (b = (a != c ? a : b++)) evaluates to b = (2 != 2 ? a : b++), which is false, so b++ is executed, and b is incremented to 6. The third expression (a > b ? b < c ? b : 2 : 1) evaluates to 2 > 6 ? b < 2 ? b : 2 : 1, which is false, so 1 is returned. Therefore, the unique outputs are 2 and 4."
    },
    {
        "question": "Which is not an output of the following code snippet?",
        "code": "short height = 1, weight = 3;\nshort zebra = (byte) weight * (byte) height;\ndouble ox = 1 + height * 2 + weight;\nlong giraffe = 1 + 9 % height + 1;\nSystem.out.println(zebra);\nSystem.out.println(ox);\nSystem.out.println(giraffe);",
        "options": [
            "A. 2",
            "B. 3",
            "C. 6",
            "D. 6.0",
            "E. The code does not compile."
        ],
        "answer": [
            "C"
        ],
        "explanation": "The expression (byte) weight * (byte) height evaluates to 3 * 1 = 3, so zebra is 3. The expression 1 + height * 2 + weight evaluates to 1 + 1 * 2 + 3 = 1 + 2 + 3 = 6.0, so ox is 6.0. The expression 1 + 9 % height + 1 evaluates to 1 + 9 % 1 + 1 = 1 + 0 + 1 = 2, so giraffe is 2. Therefore, the output 6 is not produced."
    },
    {
        "question": "What is the output of the following code?",
        "code": "11: int sample1 = (2 * 4) % 3;\n12: int sample2 = 3 * 2 % -3;\n13: int sample3 = 5 * (1 % 2);\n14: System.out.println(sample1 + \", \" + sample2 + \", \" + sample3);",
        "options": [
            "A. 0, 0, 5",
            "B. 1, 2, 10",
            "C. 2, 1, 5",
            "D. 2, 0, 5",
            "E. 3, 1, 10",
            "F. 3, 2, 6",
            "G. The code does not compile."
        ],
        "answer": [
            "D"
        ],
        "explanation": "The expression (2 * 4) % 3 evaluates to 8 % 3 = 2, so sample1 is 2. The expression 3 * 2 % -3 evaluates to 6 % -3 = 0, so sample2 is 0. The expression 5 * (1 % 2) evaluates to 5 * 1 = 5, so sample3 is 5. Therefore, the output is 2, 0, 5."
    },
    {
        "question": "The _________ operator increases a value and returns the original value, while the _______ operator decreases a value and returns the new value.",
        "options": [
            "A. post-increment, post-increment",
            "B. pre-decrement, post-decrement",
            "C. post-increment, post-decrement",
            "D. post-increment, pre-decrement",
            "E. pre-increment, pre-decrement",
            "F. pre-increment, post-decrement"
        ],
        "answer": [
            "C"
        ],
        "explanation": "The post-increment operator (i++) increases a value and returns the original value, while the post-decrement operator (i--) decreases a value and returns the new value."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "boolean sunny = true, raining = false, sunday = true;\nboolean goingToTheStore = sunny & raining ^ sunday;\nboolean goingToTheZoo = sunday && !raining;\nboolean stayingHome = !(goingToTheStore && goingToTheZoo);\nSystem.out.println(goingToTheStore + \"-\" + goingToTheZoo + \"-\" +stayingHome);",
        "options": [
            "A. true-false-false",
            "B. false-true-false",
            "C. true-true-true",
            "D. false-true-true",
            "E. false-false-false",
            "F. true-true-false",
            "G. None of the above"
        ],
        "answer": [
            "D"
        ],
        "explanation": "The expression sunny & raining ^ sunday evaluates to true & false ^ true = false ^ true = true, so goingToTheStore is true. The expression sunday && !raining evaluates to true && true = true, so goingToTheZoo is true. The expression !(goingToTheStore && goingToTheZoo) evaluates to !(true && true) = !(true) = false, so stayingHome is false. Therefore, the output is true-true-false."
    },
    {
        "question": "Which of the following statements are correct? (Choose all that apply.)",
        "options": [
            "A. The return value of an assignment operation expression can be void.",
            "B. The inequality operator (!=) can be used to compare objects.",
            "C. The equality operator (==) can be used to compare a boolean value with a numeric value.",
            "D. During runtime, the & and | operators may cause only the left side of the expression to be evaluated.",
            "E. The return value of an assignment operation expression is the value of the newly assigned variable.",
            "F. In Java, 0 and false may be used interchangeably.",
            "G. The logical complement operator (!) cannot be used to flip numeric values."
        ],
        "answer": [
            "B",
            "E",
            "G"
        ],
        "explanation": "The inequality operator (!=) can be used to compare objects. The return value of an assignment operation expression is the value of the newly assigned variable. The logical complement operator (!) cannot be used to flip numeric values. Option A is incorrect because the return value of an assignment operation expression cannot be void. Option C is incorrect because the equality operator (==) cannot be used to compare a boolean value with a numeric value. Option D is incorrect because the & and | operators always evaluate both sides of the expression. Option F is incorrect because in Java, 0 and false cannot be used interchangeably."
    },
    {
        "question": "Which operator takes three operands or values?",
        "options": [
            "A. =",
            "B. &&",
            "C. *=",
            "D. ? :",
            "E. &",
            "F. ++",
            "G. /"
        ],
        "answer": [
            "D"
        ],
        "explanation": "The ternary operator ( ? : ) takes three operands or values."
    },
    {
        "question": "How many lines of the following code contain compiler errors?",
        "code": "int note = 1 * 2 + (long)3;\nshort melody = (byte)(double)(note *= 2);\ndouble song = melody;\nfloat symphony = (float)((song == 1_000f) ? song * 2L : song);",
        "options": [
            "A. 0",
            "B. 1",
            "C. 2",
            "D. 3",
            "E. 4"
        ],
        "answer": [
            "A"
        ],
        "explanation": "There are no compiler errors in the code. All lines compile successfully."
    },
    {
        "question": "Given the following code snippet, what are the values of the variables after it is executed? (Choose all that apply.)",
        "code": "int ticketsTaken = 1;\nint ticketsSold = 3;\nticketsSold += 1 + ticketsTaken++;\nticketsTaken *= 2;\nticketsSold += (long)1;",
        "options": [
            "A. ticketsSold is 8.",
            "B. ticketsTaken is 2.",
            "C. ticketsSold is 6.",
            "D. ticketsTaken is 6.",
            "E. ticketsSold is 7.",
            "F. ticketsTaken is 4.",
            "G. The code does not compile."
        ],
        "answer": [
            "E",
            "F"
        ],
        "explanation": "After the code is executed, ticketsSold is 7 and ticketsTaken is 4. The expression ticketsSold += 1 + ticketsTaken++ evaluates to ticketsSold += 1 + 1, so ticketsSold becomes 5 and ticketsTaken becomes 2. The expression ticketsTaken *= 2 evaluates to ticketsTaken = 2 * 2, so ticketsTaken becomes 4. The expression ticketsSold += (long)1 evaluates to ticketsSold = 5 + 1, so ticketsSold becomes 6."
    },
    {
        "question": "Which of the following can be used to change the order of operation in an expression?",
        "options": [
            "A. [ ]",
            "B. < >",
            "C. ( )",
            "D. \\ /",
            "E. { }",
            "F. \" \""
        ],
        "answer": [
            "C"
        ],
        "explanation": "Parentheses ( ) can be used to change the order of operation in an expression."
    },
    {
        "question": "What is the result of executing the following code snippet? (Choose all that apply.)",
        "code": "3: int start = 7;\n4: int end = 4;\n5: end += ++start;\n6: start = (byte)(Byte.MAX_VALUE + 1);",
        "options": [
            "A. start is 0.",
            "B. start is -128.",
            "C. start is 127.",
            "D. end is 8.",
            "E. end is 11.",
            "F. end is 12.",
            "G. The code does not compile.",
            "H. The code compiles but throws an exception at runtime."
        ],
        "answer": [
            "B",
            "E"
        ],
        "explanation": "The expression end += ++start evaluates to end = 4 + 8, so end becomes 12. The expression start = (byte)(Byte.MAX_VALUE + 1) evaluates to start = (byte)(127 + 1), which is -128 due to overflow. Therefore, start is -128 and end is 12."
    },
    {
        "question": "Which of the following statements about unary operators are true? (Choose all that apply.)",
        "options": [
            "A. Unary operators are always executed before any surrounding numeric binary or ternary operators.",
            "B. The - operator can be used to flip a boolean value.",
            "C. The pre-increment operator (++) returns the value of the variable before the increment is applied.",
            "D. The post-decrement operator (--) returns the value of the variable before the decrement is applied.",
            "E. The ! operator cannot be used on numeric values.",
            "F. None of the above."
        ],
        "answer": [
            "A",
            "E"
        ],
        "explanation": "Unary operators are always executed before any surrounding numeric binary or ternary operators. The ! operator cannot be used on numeric values. Option B is incorrect because the - operator cannot be used to flip a boolean value. Option C is incorrect because the pre-increment operator (++) returns the value of the variable after the increment is applied. Option D is incorrect because the post-decrement operator (--) returns the value of the variable after the decrement is applied."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "32: Object skips = 10;\n33: switch (skips) {\n34: case a when a < 10 -> System.out.print(2);\n35: case b when b>= 10 -> System.out.print(4);\n36: case null -> System.out.print(6);\n37: default -> System.out.print(8);\n38: }",
        "options": [
            "A. 2",
            "B. 4",
            "C. 6",
            "D. 8",
            "E. Exactly one line does not compile.",
            "F. Exactly two lines do not compile.",
            "G. None of the above."
        ],
        "answer": [
            "B"
        ],
        "explanation": "Since this is a pattern matching switch statement, the case branches are evaluated in the order in which they appear. In particular, each branch does not dominate the ones after it, so the code compiles without issue. If either of the when clauses were removed from their accompanying case clause, then the code would not compile. The first branch is skipped because Closed does not match Open. The second one matches, resulting in 20 being printed at runtime and making option B correct."
    },
    {
        "question": "Which of the following data types can be used in a switch expression? (Choose all that apply.)",
        "options": [
            "A. enum",
            "B. int",
            "C. Byte",
            "D. long",
            "E. boolean",
            "F. double"
        ],
        "answer": [
            "A",
            "B",
            "C"
        ],
        "explanation": "A switch expression supports enum values, making option A correct. It also supports int and byte primitives, including their wrapper classes Integer and Byte, making options B and C correct. It does not support the other types."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "3: int temperature = 4;\n4: long humidity = -temperature + temperature * 3;\n5: if (temperature>=4)\n6: if (humidity < 6) System.out.println(\"Too Low\");\n7: else System.out.println(\"Just Right\");\n8: else System.out.println(\"Too High\");",
        "options": [
            "A. Too Low",
            "B. Just Right",
            "C. Too High",
            "D. A NullPointerException is thrown at runtime.",
            "E. The code will not compile because of line 7.",
            "F. The code will not compile because of line 8."
        ],
        "answer": [
            "B"
        ],
        "explanation": "The code compiles and runs without issue, so options D, E, and F are incorrect. Even though two consecutive else statements on lines 7 and 8 look a little odd, they are associated with separate if statements on lines 5 and 6, respectively. The value of humidity on line 4 is equal to -4 + 12, which is 8. The first if statement evaluates to true on line 5, so line 6 is executed and evaluates to false. This causes the else statement on line 7 to run, printing Just Right and making option B the correct answer."
    },
    {
        "question": "Which of the following data types are permitted on the right side of a for-each expression? (Choose all that apply.)",
        "options": [
            "A. Double[][]",
            "B. Object",
            "C. Map",
            "D. List",
            "E. String",
            "F. char[]",
            "G. Exception"
        ],
        "answer": [
            "A",
            "D",
            "F"
        ],
        "explanation": "A for-each loop supports arrays, making options A and F correct. For Double[][], each element of the for-each loop would be a Double[]. A for-each also supports classes that implement java.lang.Iterable. Although this includes many of the Collections Framework classes, not all of them implement java.lang.Iterable. For this reason, option C is incorrect, and option D is correct. Options B, E, and G are incorrect, as they do not implement java.lang.Iterable. Although a String is a list of ordered characters, the class does not implement the required interface for a for-each loop."
    },
    {
        "question": "What is the output of calling printReptile(6)?",
        "code": "void printReptile(int category) {\nvar type = switch (category) {\ncase 1,2 -> \"Snake\";\ncase 3,4 -> \"Lizard\";\ncase 5,6 -> \"Turtle\";\ncase 7,8 -> \"Alligator\";\n};\nSystem.out.print(type);\n}",
        "options": [
            "A. Snake",
            "B. Lizard",
            "C. Turtle",
            "D. Alligator",
            "E. TurtleAlligator",
            "F. None of the above"
        ],
        "answer": [
            "C"
        ],
        "explanation": "The code does not compile because the switch expression requires all possible case values to be handled, making option F correct. If a valid default clause was added, then the code would compile and print Turtle at runtime."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "List<Integer> myFavoriteNumbers = new ArrayList<>();\nmyFavoriteNumbers.add(10);\nmyFavoriteNumbers.add(14);\nfor (var a : myFavoriteNumbers) {\nSystem.out.print(a + \", \");\nbreak;\n}\nfor (int b : myFavoriteNumbers) {\ncontinue;\nSystem.out.print(b + \", \");\n}\nfor (Object c : myFavoriteNumbers)\nSystem.out.print(c + \", \");",
        "options": [
            "A. It compiles and runs without issue but does not produce any output.",
            "B. 10, 14,",
            "C. 10, 10, 14,",
            "D. 10, 10, 14, 10, 14,",
            "E. Exactly one line of code does not compile.",
            "F. Exactly two lines of code do not compile.",
            "G. Three or more lines of code do not compile.",
            "H. The code contains an infinite loop and does not terminate."
        ],
        "answer": [
            "E"
        ],
        "explanation": "The second for-each loop contains a continue followed by a print() statement. Because the continue is not conditional and always included as part of the body of the for-each loop, the print() statement is not reachable. For this reason, the print() statement does not compile. As this is the only compilation error, option E is correct. The other lines of code compile without issue."
    },
    {
        "question": "Assuming weather is a well-formed nonempty array, which code snippet, when inserted independently into the blank in the following code, prints all of the elements of weather? (Choose all that apply.)",
        "code": "private void print(int[] weather) {\nfor () {\nSystem.out.println(weather[i]);\n}\n}",
        "options": [
            "A. int i=weather.length; i>0; i--",
            "B. int i=0; i<=weather.length-1; ++i",
            "C. var w : weather",
            "D. int i=weather.length-1; i>=0; i--",
            "E. int i=0, int j=3; i<weather.length; ++i",
            "F. int i=0; ++i<10 && i<weather.length;",
            "G. None of the above"
        ],
        "answer": [
            "B",
            "D"
        ],
        "explanation": "Option A is incorrect because on the first iteration, it attempts to access weather[weather.length] of the nonempty array, which causes an ArrayIndexOutOfBoundsException to be thrown. Option B is correct and will print the elements in order. Option C doesn’t compile as i is undefined in weather[i]. For this to work, the body of the for-each loop would have to be updated as well. Option D is also correct and is a common way to print the elements of an array in reverse order. Option E does not compile and is therefore incorrect. You can declare multiple elements in a for loop, but the data type must be listed only once, such as in for (int i=0, j=3; …). Finally, option F is incorrect because the first element of the array is skipped. Since the conditional expression is checked before the loop is executed the first time, the first value of i used inside the body of the loop will be 1."
    },
    {
        "question": "What is the output of calling printType(11)?",
        "code": "31: void printType(Object o) {\n32: if (o instanceof Integer bat) {\n33: System.out.print(\"int\");\n34: } else if (o instanceof Integer bat && bat < 10) {\n35: System.out.print(\"small int\");\n36: } else if (o instanceof Long bat || bat <= 20) {\n37: System.out.print(\"long\");\n38: } default {\n39: System.out.print(\"unknown\");\n40: }\n41: }",
        "options": [
            "A. int",
            "B. small int",
            "C. long",
            "D. unknown",
            "E. Nothing is printed.",
            "F. The code contains one line that does not compile.",
            "G. The code contains two lines that do not compile.",
            "H. None of the above."
        ],
        "answer": [
            "G"
        ],
        "explanation": "The first two pattern matching statements compile without issue. The variable bat is allowed to be used again, provided it is no longer in scope. Line 36 does not compile, though. Due to flow scoping, if o is not a Long, then bat is not in scope in the expression bat <= 20. Line 38 also does not compile as default cannot be used as part of an if/else statement. For these two reasons, option G is correct."
    },
    {
        "question": "Which statements, when inserted independently into the following blank, will cause the code to print 2 at runtime? (Choose all that apply.)",
        "code": "int count = 0;\nBUNNY: for (int row = 1; row <=3; row++)\nRABBIT: for (int col = 0; col <3 ; col++) {\nif ((col + row) % 2 == 0)\n;\ncount++;\n}\nSystem.out.println(count);",
        "options": [
            "A. break BUNNY",
            "B. break RABBIT",
            "C. continue BUNNY",
            "D. continue RABBIT",
            "E. break",
            "F. continue",
            "G. None of the above, as the code contains a compiler error"
        ],
        "answer": [
            "B",
            "C",
            "E"
        ],
        "explanation": "The code contains a nested loop and a conditional expression that is executed if the sum of col + row is an even number; otherwise, count is incremented. Note that options E and F are equivalent to options B and D, respectively, since unlabeled statements apply to the most inner loop. Studying the loops, the first time the condition is true is in the second iteration of the inner loop, when row is 1 and col is 1. Option A is incorrect because this causes the loop to exit immediately with count only being set to 1. Options B, C, and E follow the same pathway. First, count is incremented to 1 on the first inner loop, and then the inner loop is exited. On the next iteration of the outer loop, row is 2 and col is 0, so execution exits the inner loop immediately. On the third iteration of the outer loop, row is 3 and col is 0, so count is incremented to 2. In the next iteration of the inner loop, the sum is even, so we exit, and our program is complete, making options B, C, and E each correct. Options D and F are both incorrect, as they cause the inner and outer loops to execute multiple times, with count having a value of 5 when done. You don’t need to trace through all the iterations; just stop when the value of count exceeds 2."
    },
    {
        "question": "Given the following method, how many lines contain compilation errors?",
        "code": "8: enum DayOfWeek {\n9: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY;\n10: private DayOfWeek getWeekDay(int day, final int thursday) {\n11: int otherDay = day;\n12: int Sunday = 0;\n13: switch (otherDay) {\n14: default:\n15: case 1: continue;\n16: case thursday: return DayOfWeek.THURSDAY;\n17: case 2,10: break;\n18: case Sunday: return DayOfWeek.SUNDAY;\n19: case DayOfWeek.MONDAY: return DayOfWeek.MONDAY;\n20: }\n21: return DayOfWeek.FRIDAY;\n22: } }",
        "options": [
            "A. None, the code compiles and runs without issue.",
            "B. 1.",
            "C. 2.",
            "D. 3.",
            "E. 4.",
            "F. 5.",
            "G. 6.",
            "H. The code compiles but may produce an error at runtime."
        ],
        "answer": [
            "E"
        ],
        "explanation": "This code contains numerous compilation errors, making options A and H incorrect. Line 15 does not compile, as continue cannot be used inside a switch statement like this. Line 16 is not a compile-time constant since any int value can be passed as a parameter. Marking it final does not change this, so it doesn’t compile. Line 18 does not compile because Sunday is not marked as final. Being effectively final is insufficient. Finally, line 19 does not compile because DayOfWeek.MONDAY is not an int value. While switch statements do support enum values, each case clause must have the same data type as the switch variable otherDay, which is int. The rest of the lines do compile. Since exactly four lines do not compile, option E is the correct answer."
    },
    {
        "question": "What is the output of calling printLocation(Animal.MAMMAL)?",
        "code": "10: class Zoo {\n11: enum Animal {BIRD, FISH, MAMMAL}\n12: void printLocation(Animal a) {\n13: long type = switch (a) {\n14: case BIRD -> 1;\n15: case FISH -> 2;\n16: case MAMMAL -> 3;\n17: default -> 4;\n18: };\n19: System.out.print(type);\n20: } }",
        "options": [
            "A. 3",
            "B. 4",
            "C. 34",
            "D. The code does not compile because of line 13.",
            "E. The code does not compile because of line 17.",
            "F. None of the above."
        ],
        "answer": [
            "A"
        ],
        "explanation": "The code compiles and runs without issue, printing 3 at runtime and making option A correct. The default clause on line 17 is optional since all the enum values are accounted for and can be removed without changing the output."
    },
    {
        "question": "What is the result of the following code snippet?",
        "code": "3: int sing = 8, squawk = 2, notes = 0;\n4: while (sing > squawk) {\n5: sing--;\n6: squawk += 2;\n7: notes += sing + squawk;\n8: }\n9: System.out.println(notes);",
        "options": [
            "A. 11",
            "B. 13",
            "C. 23",
            "D. 33",
            "E. 50",
            "F. The code will not compile because of line 7."
        ],
        "answer": [
            "C"
        ],
        "explanation": "Prior to the first iteration, sing = 8, squawk = 2, and notes = 0. After the iteration of the first loop, sing is updated to 7, squawk to 4, and notes to the sum of the new values for sing + squawk, 7 + 4 = 11. After the iteration of the second loop, sing is updated to 6, squawk to 6, and notes to the sum of itself plus the new values for sing + squawk, 11 + 6 + 6 = 23. On the third iteration of the loop, sing > squawk evaluates to false, as 6 > 6 is false. The loop ends and the most recent value of sing, 23, is output, so the correct answer is option C."
    },
    {
        "question": "What is the result of calling getHatSize(9f) on the following code snippet?",
        "code": "10: int getHatSize(Number measurement) {\n11: return switch (measurement) {\n12: case Double d -> 1 + d.intValue();\n13: case null -> 11;\n14: case !(Number n) -> 3 + n.intValue();\n15: case Float f when f < 10 -> 4 + f.intValue();\n16: };\n17: }",
        "options": [
            "A. 10",
            "B. 11",
            "C. 12",
            "D. 13",
            "E. The code does not compile because it is missing a default clause.",
            "F. The code does not compile for a different reason."
        ],
        "answer": [
            "F"
        ],
        "explanation": "The code does not compile because case clause uses the logical complement operator (!), which is not permitted with pattern matching. If this was removed, then the code would still not compile, as this clause would dominate the case on line 15, leading to unreachable code on line 15. For this reason, option F is correct."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "2: boolean keepGoing = true;\n3: int result = 15, meters = 10;\n4: do {\n5: meters--;\n6: if (meters == 8) keepGoing = false;\n7: result -= 2;\n8: } while keepGoing;\n9: System.out.println(result);",
        "options": [
            "A. 7",
            "B. 9",
            "C. 10",
            "D. 11",
            "E. 15",
            "F. The code will not compile because of line 6.",
            "G. The code does not compile for a different reason."
        ],
        "answer": [
            "G"
        ],
        "explanation": "This example may look complicated, but the code does not compile. Line 8 is missing the required parentheses around the boolean conditional expression. Since the code does not compile and it is not because of line 6, option G is the correct answer. If line 8 was corrected with parentheses, then the loop would be executed twice, and the output would be 11."
    },
    {
        "question": "Which statements about the following code snippet are correct? (Choose all that apply.)",
        "code": "for (var penguin : new int[2])\nSystem.out.println(penguin);\nvar ostrich = new Character[3];\nfor (var emu : ostrich)\nSystem.out.println(emu);\nList<Integer> parrots = new ArrayList<Integer>();\nfor (var macaw : parrots)\nSystem.out.println(macaw);",
        "options": [
            "A. The data type of penguin is Integer.",
            "B. The data type of penguin is int.",
            "C. The data type of emu is undefined.",
            "D. The data type of emu is Character.",
            "E. The data type of macaw is List.",
            "F. The data type of macaw is Integer.",
            "G. None of the above, as the code does not compile."
        ],
        "answer": [
            "B",
            "D",
            "F"
        ],
        "explanation": "The code does compile, making option G incorrect. In the first for-each loop, the right side of the for-each loop has a type of int[], so each element penguin has a type of int, making option B correct. In the second for-each loop, ostrich has a type of Character[], so emu has a data type of Character, making option D correct. In the last for-each loop, parrots has a data type of List<Integer>. Since the generic type of Integer is used in the List, macaw will have a data type of Integer, making option F correct."
    },
    {
        "question": "What is the result of the following code snippet?",
        "code": "final char a = 'A', e = 'E';\nchar grade = 'B';\nswitch (grade) {\ndefault:\ncase a:\ncase 'B': 'C': System.out.print(\"great \");\ncase 'D':\nSystem.out.print(\"good \"); break;\ncase e:\ncase 'F':\nSystem.out.print(\"not good \");\n}",
        "options": [
            "A. great",
            "B. great good",
            "C. good",
            "D. not good",
            "E. The code does not compile because the data type of one or more case clauses does not match the data type of the switch variable.",
            "F. None of the above."
        ],
        "answer": [
            "F"
        ],
        "explanation": "The code does not compile, although not for the reason specified in option E. The second case clause contains invalid syntax. Each case clause must have the keyword case—in other words, you cannot chain them with a colon (:). For this reason, option F is the correct answer. This line could have been fixed to say case ’B’, ’C’ or by adding the case keyword before ’C’; then the rest of the code would have compiled and printed great good at runtime."
    },
    {
        "question": "Given the following array, which code snippets print the elements in reverse order from how they are declared? (Choose all that apply.)",
        "code": "char[] wolf = {'W', 'e', 'b', 'b', 'y'};",
        "options": [
            "A. int q = wolf.length;\nfor ( ; ; ) {\nSystem.out.print(wolf[--q]);\nif (q == 0) break;\n}",
            "B. for (int m = wolf.length - 1; m >= 0; --m)\nSystem.out.print(wolf[m]);",
            "C. for (int z = 0; z < wolf.length; z++)\nSystem.out.print(wolf[wolf.length - z]);",
            "D. int x = wolf.length - 1;\nfor (int j = 0; x >= 0 && j == 0; x--)\nSystem.out.print(wolf[x]);",
            "E. final int r = wolf.length;\nfor (int w = r - 1; r > -1; w = r - 1)\nSystem.out.print(wolf[w]);",
            "F. for (int i = wolf.length; i > 0; --i)\nSystem.out.print(wolf[i]);",
            "G. None of the above"
        ],
        "answer": [
            "A",
            "B",
            "D"
        ],
        "explanation": "To print items in the wolf array in reverse order, the code needs to start with wolf[wolf.length-1] and end with wolf[0]. Option A accomplishes this and is the first correct answer. Option B is also correct and is one of the most common ways a reverse loop is written. The termination condition is often m>=0 or m>-1, and both are correct. Options C and F each cause an ArrayIndexOutOfBoundsException at runtime since both read from wolf[wolf.length] first, with an index that is passed the length of the 0-based array wolf. The form of option C would be successful if the value was changed to wolf[wolf.length-z-1]. Option D is also correct, as the j is extraneous and can be ignored in this example. Finally, option E is incorrect and produces an infinite loop, as w is repeatedly set to r-1, in this case 4, on every loop iteration. Since the update statement has no effect after the first iteration, the condition is never met, and the loop never terminates."
    },
    {
        "question": "What distinct numbers are printed when the following method is executed? (Choose all that apply.)",
        "code": "private void countAttendees() {\nint participants = 4, animals = 2, performers = -1;\nwhile ((participants = participants + 1) < 10) {}\ndo {} while (animals++ <= 1);\nfor ( ; performers < 2; performers += 2) {}\nSystem.out.println(participants);\nSystem.out.println(animals);\nSystem.out.println(performers);\n}",
        "options": [
            "A. 6",
            "B. 3",
            "C. 4",
            "D. 5",
            "E. 10",
            "F. 9",
            "G. The code does not compile.",
            "H. None of the above."
        ],
        "answer": [
            "B",
            "E"
        ],
        "explanation": "The code compiles without issue and prints two distinct numbers at runtime, so options G and H are incorrect. The first loop executes a total of five times, with the loop ending when participants has a value of 10. For this reason, option E is correct. In the second loop, animals starts out not less than or equal to 1, but since it is a do/while loop, it executes at least once. In this manner, animals takes on a value of 3 and the loop terminates, making option B correct. Finally, the last loop executes a total of two times, with performers starting with -1, going to 1 at the end of the first loop, and then ending with a value of 3 after the second loop, which breaks the loop. This makes option B a correct answer twice over."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "2: double iguana = 0;\n3: do {\n4: int snake = 1;\n5: System.out.print(snake++ + \" \");\n6: iguana--;\n7: } while (snake <= 5);\n8: System.out.println(iguana);",
        "options": [
            "A. 1 2 3 4 -4.0",
            "B. 1 2 3 4 -5.0",
            "C. 1 2 3 4 5 -4.0",
            "D. 0 1 2 3 4 5 -5.0",
            "E. The code does not compile.",
            "F. The code compiles but produces an infinite loop at runtime.",
            "G. None of the above."
        ],
        "answer": [
            "E"
        ],
        "explanation": "The variable snake is declared within the body of the do/while statement, so it is out of scope on line 7. For this reason, option E is the correct answer. If snake were declared before line 3 with a value of 1, then the output would have been 1 2 3 4 5 -5.0, and option G would have been the correct answer."
    },
    {
        "question": "Which statements, when inserted into the following blanks, allow the code to compile and run without entering an infinite loop? (Choose all that apply.)",
        "code": "4: int height = 1;\n5: L1: while (height++ < 10) {\n6: long humidity = 12;\n7: L2: do {\n8: if (humidity-- % 12 == 0) ;\n9: int temperature = 30;\n10: L3: for ( ; ; ) {\n11: temperature++;\n12: if (temperature > 50) ;\n13: }\n14: } while (humidity > 4);\n15: }",
        "options": [
            "A. break L2 on line 8; continue L2 on line 12",
            "B. continue on line 8; continue on line 12",
            "C. break L3 on line 8; break L1 on line 12",
            "D. continue L2 on line 8; continue L3 on line 12",
            "E. continue L2 on line 8; continue L2 on line 12",
            "F. None of the above, as the code contains a compiler error"
        ],
        "answer": [
            "A",
            "E"
        ],
        "explanation": "The most important thing to notice when reading this code is that the innermost loop is an infinite loop. Therefore, you are looking for solutions that skip the innermost loop entirely or that exit that loop. Option A is correct, as break L2 on line 8 causes the second inner loop to exit every time it is entered, skipping the innermost loop entirely. For option B, the first continue on line 8 causes the execution to skip the innermost loop on the first iteration of the second loop but not the second iteration of the second loop. The innermost loop is executed, and with continue on line 12, it produces an infinite loop at runtime, making option B incorrect. Option C is incorrect because it contains a compiler error. The label L3 is not visible outside its loop. Option D is incorrect, as it is equivalent to option B since the unlabeled break and continue apply to the nearest loop and therefore produce an infinite loop at runtime. Like option A, the continue L2 on line 8 allows the innermost loop to be executed the second time the second loop is called. The continue L2 on line 12 exits the infinite loop, though, causing control to return to the second loop. Since the first and second loops terminate, the code terminates, and option E is a correct answer."
    },
    {
        "question": "A minimum of how many lines need to be corrected before the following method will compile?",
        "code": "21: void findZookeeper(Integer id) {\n22: System.out.print(switch (id) {\n23: case 10 -> {\"Jane\";}\n24: case 20 -> {yield \"Lisa\";};\n25: case 30 -> \"Kelly\";\n26: case 30 -> \"Sarah\";\n27: default -> \"Unassigned\";\n28: });\n29: }",
        "options": [
            "A. Zero",
            "B. One",
            "C. Two",
            "D. Three",
            "E. Four",
            "F. Five"
        ],
        "answer": [
            "D"
        ],
        "explanation": "Line 23 does not compile because it is missing a yield statement. Line 24 does not compile because it contains an extra semicolon at the end. Finally, lines 25 and 26 do not compile because they use the same case value. At least one of them would need to be changed for the code to compile. Since three lines need to be corrected, option D is correct."
    },
    {
        "question": "What is the output of calling printLocation(Animal.MAMMAL)?",
        "code": "10: class Zoo {\n11: enum Animal {BIRD, FISH, MAMMAL}\n12: void printLocation(Animal a) {\n13: long type = switch (a) {\n14: case BIRD -> 1;\n15: case FISH -> 2;\n16: case MAMMAL -> 3;\n17: default -> 4;\n18: };\n19: System.out.print(type);\n20: } }",
        "options": [
            "A. 3",
            "B. 4",
            "C. 34",
            "D. The code does not compile because of line 13.",
            "E. The code does not compile because of line 17.",
            "F. None of the above."
        ],
        "answer": [
            "A"
        ],
        "explanation": "The code compiles and runs without issue, printing 3 at runtime and making option A correct. The default clause on line 17 is optional since all the enum values are accounted for and can be removed without changing the output."
    },
    {
        "question": "What is the result of the following code snippet?",
        "code": "3: int sing = 8, squawk = 2, notes = 0;\n4: while (sing > squawk) {\n5: sing--;\n6: squawk += 2;\n7: notes += sing + squawk;\n8: }\n9: System.out.println(notes);",
        "options": [
            "A. 11",
            "B. 13",
            "C. 23",
            "D. 33",
            "E. 50",
            "F. The code will not compile because of line 7."
        ],
        "answer": [
            "C"
        ],
        "explanation": "Prior to the first iteration, sing = 8, squawk = 2, and notes = 0. After the iteration of the first loop, sing is updated to 7, squawk to 4, and notes to the sum of the new values for sing + squawk, 7 + 4 = 11. After the iteration of the second loop, sing is updated to 6, squawk to 6, and notes to the sum of itself plus the new values for sing + squawk, 11 + 6 + 6 = 23. On the third iteration of the loop, sing > squawk evaluates to false, as 6 > 6 is false. The loop ends and the most recent value of sing, 23, is output, so the correct answer is option C."
    },
    {
        "question": "What is the result of calling getHatSize(9f) on the following code snippet?",
        "code": "10: int getHatSize(Number measurement) {\n11: return switch (measurement) {\n12: case Double d -> 1 + d.intValue();\n13: case null -> 11;\n14: case !(Number n) -> 3 + n.intValue();\n15: case Float f when f < 10 -> 4 + f.intValue();\n16: };\n17: }",
        "options": [
            "A. 10",
            "B. 11",
            "C. 12",
            "D. 13",
            "E. The code does not compile because it is missing a default clause.",
            "F. The code does not compile for a different reason."
        ],
        "answer": [
            "F"
        ],
        "explanation": "The code does not compile because case clause uses the logical complement operator (!), which is not permitted with pattern matching. If this was removed, then the code would still not compile, as this clause would dominate the case on line 15, leading to unreachable code on line 15. For this reason, option F is correct."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "2: boolean keepGoing = true;\n3: int result = 15, meters = 10;\n4: do {\n5: meters--;\n6: if (meters == 8) keepGoing = false;\n7: result -= 2;\n8: } while keepGoing;\n9: System.out.println(result);",
        "options": [
            "A. 7",
            "B. 9",
            "C. 10",
            "D. 11",
            "E. 15",
            "F. The code will not compile because of line 6.",
            "G. The code does not compile for a different reason."
        ],
        "answer": [
            "G"
        ],
        "explanation": "This example may look complicated, but the code does not compile. Line 8 is missing the required parentheses around the boolean conditional expression. Since the code does not compile and it is not because of line 6, option G is the correct answer. If line 8 was corrected with parentheses, then the loop would be executed twice, and the output would be 11."
    },
    {
        "question": "Which statements about the following code snippet are correct? (Choose all that apply.)",
        "code": "for (var penguin : new int[2])\nSystem.out.println(penguin);\nvar ostrich = new Character[3];\nfor (var emu : ostrich)\nSystem.out.println(emu);\nList<Integer> parrots = new ArrayList<Integer>();\nfor (var macaw : parrots)\nSystem.out.println(macaw);",
        "options": [
            "A. The data type of penguin is Integer.",
            "B. The data type of penguin is int.",
            "C. The data type of emu is undefined.",
            "D. The data type of emu is Character.",
            "E. The data type of macaw is List.",
            "F. The data type of macaw is Integer.",
            "G. None of the above, as the code does not compile."
        ],
        "answer": [
            "B",
            "D",
            "F"
        ],
        "explanation": "The code does compile, making option G incorrect. In the first for-each loop, the right side of the for-each loop has a type of int[], so each element penguin has a type of int, making option B correct. In the second for-each loop, ostrich has a type of Character[], so emu has a data type of Character, making option D correct. In the last for-each loop, parrots has a data type of List<Integer>. Since the generic type of Integer is used in the List, macaw will have a data type of Integer, making option F correct."
    },
    {
        "question": "What is the result of the following code snippet?",
        "code": "final char a = 'A', e = 'E';\nchar grade = 'B';\nswitch (grade) {\ndefault:\ncase a:\ncase 'B': 'C': System.out.print(\"great \");\ncase 'D':\nSystem.out.print(\"good \"); break;\ncase e:\ncase 'F':\nSystem.out.print(\"not good \");\n}",
        "options": [
            "A. great",
            "B. great good",
            "C. good",
            "D. not good",
            "E. The code does not compile because the data type of one or more case clauses does not match the data type of the switch variable.",
            "F. None of the above."
        ],
        "answer": [
            "F"
        ],
        "explanation": "The code does not compile, although not for the reason specified in option E. The second case clause contains invalid syntax. Each case clause must have the keyword case—in other words, you cannot chain them with a colon (:). For this reason, option F is the correct answer. This line could have been fixed to say case ’B’, ’C’ or by adding the case keyword before ’C’; then the rest of the code would have compiled and printed great good at runtime."
    },
    {
        "question": "Given the following array, which code snippets print the elements in reverse order from how they are declared? (Choose all that apply.)",
        "code": "char[] wolf = {'W', 'e', 'b', 'b', 'y'};",
        "options": [
            "A. int q = wolf.length;\nfor ( ; ; ) {\nSystem.out.print(wolf[--q]);\nif (q == 0) break;\n}",
            "B. for (int m = wolf.length - 1; m >= 0; --m)\nSystem.out.print(wolf[m]);",
            "C. for (int z = 0; z < wolf.length; z++)\nSystem.out.print(wolf[wolf.length - z]);",
            "D. int x = wolf.length - 1;\nfor (int j = 0; x >= 0 && j == 0; x--)\nSystem.out.print(wolf[x]);",
            "E. final int r = wolf.length;\nfor (int w = r - 1; r > -1; w = r - 1)\nSystem.out.print(wolf[w]);",
            "F. for (int i = wolf.length; i > 0; --i)\nSystem.out.print(wolf[i]);",
            "G. None of the above"
        ],
        "answer": [
            "A",
            "B",
            "D"
        ],
        "explanation": "To print items in the wolf array in reverse order, the code needs to start with wolf[wolf.length-1] and end with wolf[0]. Option A accomplishes this and is the first correct answer. Option B is also correct and is one of the most common ways a reverse loop is written. The termination condition is often m>=0 or m>-1, and both are correct. Options C and F each cause an ArrayIndexOutOfBoundsException at runtime since both read from wolf[wolf.length] first, with an index that is passed the length of the 0-based array wolf. The form of option C would be successful if the value was changed to wolf[wolf.length-z-1]. Option D is also correct, as the j is extraneous and can be ignored in this example. Finally, option E is incorrect and produces an infinite loop, as w is repeatedly set to r-1, in this case 4, on every loop iteration. Since the update statement has no effect after the first iteration, the condition is never met, and the loop never terminates."
    },
    {
        "question": "What distinct numbers are printed when the following method is executed? (Choose all that apply.)",
        "code": "private void countAttendees() {\nint participants = 4, animals = 2, performers = -1;\nwhile ((participants = participants + 1) < 10) {}\ndo {} while (animals++ <= 1);\nfor ( ; performers < 2; performers += 2) {}\nSystem.out.println(participants);\nSystem.out.println(animals);\nSystem.out.println(performers);\n}",
        "options": [
            "A. 6",
            "B. 3",
            "C. 4",
            "D. 5",
            "E. 10",
            "F. 9",
            "G. The code does not compile.",
            "H. None of the above."
        ],
        "answer": [
            "B",
            "E"
        ],
        "explanation": "The code compiles without issue and prints two distinct numbers at runtime, so options G and H are incorrect. The first loop executes a total of five times, with the loop ending when participants has a value of 10. For this reason, option E is correct. In the second loop, animals starts out not less than or equal to 1, but since it is a do/while loop, it executes at least once. In this manner, animals takes on a value of 3 and the loop terminates, making option B correct. Finally, the last loop executes a total of two times, with performers starting with -1, going to 1 at the end of the first loop, and then ending with a value of 3 after the second loop, which breaks the loop. This makes option B a correct answer twice over."
    },
    {
        "question": "What is the output of the following code snippet?",
        "code": "2: double iguana = 0;\n3: do {\n4: int snake = 1;\n5: System.out.print(snake++ + \" \");\n6: iguana--;\n7: } while (snake <= 5);\n8: System.out.println(iguana);",
        "options": [
            "A. 1 2 3 4 -4.0",
            "B. 1 2 3 4 -5.0",
            "C. 1 2 3 4 5 -4.0",
            "D. 0 1 2 3 4 5 -5.0",
            "E. The code does not compile.",
            "F. The code compiles but produces an infinite loop at runtime.",
            "G. None of the above."
        ],
        "answer": [
            "E"
        ],
        "explanation": "The variable snake is declared within the body of the do/while statement, so it is out of scope on line 7. For this reason, option E is the correct answer. If snake were declared before line 3 with a value of 1, then the output would have been 1 2 3 4 5 -5.0, and option G would have been the correct answer."
    },
    {
        "question": "Which statements, when inserted into the following blanks, allow the code to compile and run without entering an infinite loop? (Choose all that apply.)",
        "code": "4: int height = 1;\n5: L1: while (height++ < 10) {\n6: long humidity = 12;\n7: L2: do {\n8: if (humidity-- % 12 == 0) ;\n9: int temperature = 30;\n10: L3: for ( ; ; ) {\n11: temperature++;\n12: if (temperature > 50) ;\n13: }\n14: } while (humidity > 4);\n15: }",
        "options": [
            "A. break L2 on line 8; continue L2 on line 12",
            "B. continue on line 8; continue on line 12",
            "C. break L3 on line 8; break L1 on line 12",
            "D. continue L2 on line 8; continue L3 on line 12",
            "E. continue L2 on line 8; continue L2 on line 12",
            "F. None of the above, as the code contains a compiler error"
        ],
        "answer": [
            "A",
            "E"
        ],
        "explanation": "The most important thing to notice when reading this code is that the innermost loop is an infinite loop. Therefore, you are looking for solutions that skip the innermost loop entirely or that exit that loop. Option A is correct, as break L2 on line 8 causes the second inner loop to exit every time it is entered, skipping the innermost loop entirely. For option B, the first continue on line 8 causes the execution to skip the innermost loop on the first iteration of the second loop but not the second iteration of the second loop. The innermost loop is executed, and with continue on line 12, it produces an infinite loop at runtime, making option B incorrect. Option C is incorrect because it contains a compiler error. The label L3 is not visible outside its loop. Option D is incorrect, as it is equivalent to option B since the unlabeled break and continue apply to the nearest loop and therefore produce an infinite loop at runtime. Like option A, the continue L2 on line 8 allows the innermost loop to be executed the second time the second loop is called. The continue L2 on line 12 exits the infinite loop, though, causing control to return to the second loop. Since the first and second loops terminate, the code terminates, and option E is a correct answer."
    },
    {
        "question": "A minimum of how many lines need to be corrected before the following method will compile?",
        "code": "21: void findZookeeper(Integer id) {\n22: System.out.print(switch (id) {\n23: case 10 -> {\"Jane\";}\n24: case 20 -> {yield \"Lisa\";};\n25: case 30 -> \"Kelly\";\n26: case 30 -> \"Sarah\";\n27: default -> \"Unassigned\";\n28: });\n29: }",
        "options": [
            "A. Zero",
            "B. One",
            "C. Two",
            "D. Three",
            "E. Four",
            "F. Five"
        ],
        "answer": [
            "D"
        ],
        "explanation": "Line 23 does not compile because it is missing a yield statement. Line 24 does not compile because it contains an extra semicolon at the end. Finally, lines 25 and 26 do not compile because they use the same case value. At least one of them would need to be changed for the code to compile. Since three lines need to be corrected, option D is correct."
    },
    {
        "question": "What is output by the following code?",
        "code": "1: public class Fish {\n2: public static void main(String[] args) {\n3: int numFish = 4;\n4: String fishType = \"tuna\";\n5: String anotherFish = numFish + 1;\n6: System.out.println(anotherFish + \" \" + fishType);\n7: System.out.println(numFish + \" \" + 1);\n8: } }",
        "options": [
            "A. 4 1",
            "B. 5",
            "C. 5 tuna",
            "D. 5tuna",
            "E. 51tuna",
            "F. The code does not compile."
        ],
        "answer": [
            "F"
        ],
        "explanation": "Line 5 does not compile. This question is checking to see whether you are paying attention to the types. numFish is an int, and 1 is an int. Therefore, we use numeric addition and get 5. The problem is that we can’t store an int in a String variable. Suppose line 5 said String anotherFish = numFish + 1 + \"\";. In that case, the answers would be option A and option C. The variable defined on line 5 would be the string \"5\", and both output statements would use concatenation."
    },
    {
        "question": "Which of these array declarations are not legal? (Choose all that apply.)",
        "options": [
            "A. int[][] scores = new int[5][];",
            "B. Object[][][] cubbies = new Object[3][0][5];",
            "C. String beans[] = new beans[6];",
            "D. java.util.Date[] dates[] = new java.util.Date[2][];",
            "E. int[][] types = new int[];",
            "F. int[][] java = new int[][];"
        ],
        "answer": [
            "C",
            "E",
            "F"
        ],
        "explanation": "Option C uses the variable name as if it were a type, which is clearly illegal. Options E and F don’t specify any size. Although it is legal to leave out the size for later dimensions of an array of arrays, the first one is required. Option A declares a legal 2D array. Option B declares a legal 3D array. Option D declares a legal 2D array. Remember that it is normal to see classes on the exam you might not have learned. You aren’t expected to know anything about them."
    },
    {
        "question": "Note that March 12, 2028, is the weekend when we spring forward, and November 5, 2028, is when we fall back for daylight saving time. Which of the following can fill in the blank without the code throwing an exception? (Choose all that apply.)",
        "code": "var zone = ZoneId.of(\"US/Eastern\");\nvar date = ______________________;\nvar time = LocalTime.of(2, 15);\nvar z = ZonedDateTime.of(date, time, zone);",
        "options": [
            "A. LocalDate.of(2028, 3, 12)",
            "B. LocalDate.of(2028, 3, 40)",
            "C. LocalDate.of(2028, 11, 5)",
            "D. LocalDate.of(2028, 11, 6)",
            "E. LocalDate.of(2029, 2, 29)",
            "F. LocalDate.of(2028, MonthEnum.MARCH, 12);"
        ],
        "answer": [
            "A",
            "C",
            "D"
        ],
        "explanation": "Option B throws an exception because there is no March 40. Option E also throws an exception because 2029 isn’t a leap year and therefore has no February 29. Option F doesn’t compile because the enum should be named Month, rather than MonthEnum. Option D is correct because it is just a regular date and has nothing to do with daylight saving time. Options A and C are correct because Java is smart enough to adjust for daylight saving time."
    },
    {
        "question": "Which of the following are output by this code? (Choose all that apply.)",
        "code": "3: var s = \"Hello\";\n4: var t = new String(s);\n5: if (\"Hello\".equals(s)) System.out.println(\"one\");\n6: if (t == s) System.out.println(\"two\");\n7: if (t.intern() == s) System.out.println(\"three\");\n8: if (\"Hello\" == s) System.out.println(\"four\");\n9: if (\"Hello\".intern() == t) System.out.println(\"five\");",
        "options": [
            "A. one",
            "B. two",
            "C. three",
            "D. four",
            "E. five",
            "F. The code does not compile.",
            "G. None of the above."
        ],
        "answer": [
            "A",
            "C",
            "D"
        ],
        "explanation": "The code compiles fine. Line 3 points to the String in the string pool. Line 4 calls the String constructor explicitly and is therefore a different object than s. Line 5 checks for object equality, which is true, and so it prints one. Line 6 uses object reference equality, which is not true since we have different objects. Line 7 calls intern(), which returns the value from the string pool and is therefore the same reference as s. Line 8 also compares references but is true since both references point to the object from the string pool. Finally, line 9 is a trick. The string Hello is already in the string pool, so calling intern() does not change anything. The reference t is a different object, so the result is still false. Therefore, options A, C, and D are correct."
    },
    {
        "question": "What is the result of the following code?",
        "code": "7: var sb = new StringBuilder();\n8: sb.append(\"aaa\").insert(1, \"bb\").insert(4, \"ccc\");\n9: System.out.println(sb);",
        "options": [
            "A. abbaaccc",
            "B. abbaccca",
            "C. bbaaaccc",
            "D. bbaaccca",
            "E. An empty line.",
            "F. The code does not compile."
        ],
        "answer": [
            "B"
        ],
        "explanation": "This example uses method chaining. After the call to append(), sb contains \"aaa\". That result is passed to the first insert() call, which inserts at index 1. At this point, sb contains abbaa. That result is passed to the final insert(), which inserts at index 4, resulting in abbaccca. Therefore, option B is the answer."
    },
    {
        "question": "How many of these lines contain a compiler error?",
        "code": "23: double one = Math.pow(1, 2);\n24: int two = Math.round(1.0);\n25: float three = Math.random();\n26: var doubles = new double[] {one, two, three};",
        "options": [
            "A. 0",
            "B. 1",
            "C. 2",
            "D. 3",
            "E. 4"
        ],
        "answer": [
            "C"
        ],
        "explanation": "Remember to watch return types on math operations. One of the tricks is line 24. The round() method returns an int when called with a float. However, we are calling it with a double, so it returns a long. The other trick is line 25. The random() method returns a double. Since two lines have a compiler error, option C is the answer."
    },
    {
        "question": "Which of these statements is true of the two values? (Choose all that apply.)",
        "code": "2025–08–28T05:00 GMT-04:00\n2025–08–28T09:00 GMT-06:00",
        "options": [
            "A. The first date/time is earlier.",
            "B. The second date/time is earlier.",
            "C. Both date/times are the same.",
            "D. The date/times are two hours apart.",
            "E. The date/times are six hours apart.",
            "F. The date/times are 10 hours apart."
        ],
        "answer": [
            "A",
            "E"
        ],
        "explanation": "When dealing with time zones, it is best to convert to GMT first by subtracting the time zone. Remember that subtracting a negative is like adding. The first date/time is 9:00 GMT, and the second is 15:00 GMT. Therefore, the first one is earlier by six hours. Therefore, options A and E are correct."
    },
    {
        "question": "Which of the following return 5 when run independently? (Choose all that apply.)",
        "code": "var string = \"12345\";\nvar builder = new StringBuilder(\"12345\");",
        "options": [
            "A. builder.charAt(4)",
            "B. builder.replace(2, 4, \"6\").charAt(3)",
            "C. builder.replace(2, 5, \"6\").charAt(2)",
            "D. string.charAt(5)",
            "E. string.length",
            "F. string.replace(\"123\", \"1\").charAt(2)",
            "G. None of the above"
        ],
        "answer": [
            "A",
            "B",
            "F"
        ],
        "explanation": "Remember that indexes are zero-based, which means index 4 corresponds to 5, and option A is correct. For option B, the replace() method starts the replacement at index 2 and ends before index 4. This means two characters are replaced, and charAt(3) is called on the intermediate value of 1265. The character at index 3 is 5, making option B correct. Option C is similar, making the intermediate value 126 and returning 6. Option D results in an exception since there is no character at index 5. Option E is incorrect. It does not compile because the parentheses for the length() method are missing. Finally, option F’s replace results in the intermediate value 145. The character at index 2 is 5, so option F is correct."
    },
    {
        "question": "Which of the following are true about arrays? (Choose all that apply.)",
        "options": [
            "A. The first element is index 0.",
            "B. The first element is index 1.",
            "C. Arrays are fixed size.",
            "D. Arrays are immutable.",
            "E. Calling equals() on two different arrays containing the same primitive values always returns true.",
            "F. Calling equals() on two different arrays containing the same primitive values always returns false.",
            "G. Calling equals() on two different arrays containing the same primitive values can return true or false."
        ],
        "answer": [
            "A",
            "C",
            "F"
        ],
        "explanation": "Arrays are zero-indexed, making option A correct and option B incorrect. They are not able to change size, which is option C. The values can be changed, making option D incorrect. An array does not override equals(), so it uses object equality. Since two different objects are not equal, option F is correct, and options E and G are incorrect."
    },
    {
        "question": "How many of these lines contain a compiler error?",
        "code": "23: int one = Math.min(5, 3);\n24: long two = Math.round(5.5);\n25: double three = Math.floor(6.6);\n26: var doubles = new double[] {one, two, three};",
        "options": [
            "A. 0",
            "B. 1",
            "C. 2",
            "D. 3",
            "E. 4"
        ],
        "answer": [
            "A"
        ],
        "explanation": "All of these lines compile. The min() and floor() methods return the same type passed in: int and double, respectively. The round() method returns a long when called with a double. Option A is correct since the code compiles."
    },
    {
        "question": "What is the output of the following code?",
        "code": "var date = LocalDate.of(2025, 4, 3);\ndate.plusDays(2);\ndate.plusHours(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \" + date.getDayOfMonth());",
        "options": [
            "A. 2025 MARCH 4",
            "B. 2025 MARCH 6",
            "C. 2025 APRIL 3",
            "D. 2025 APRIL 5",
            "E. The code does not compile.",
            "F. A runtime exception is thrown."
        ],
        "answer": [
            "E"
        ],
        "explanation": "A LocalDate does not have a time element. Therefore, there is no method to add hours, making option E the answer."
    },
    {
        "question": "What is the output of the following code?",
        "code": "var date = LocalDate.of(2025, Month.APRIL, 30);\ndate.plusDays(2);\ndate.plusYears(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth() + \" \" + date.getDayOfMonth());",
        "options": [
            "A. 2025 APRIL 30",
            "B. 2025 MAY 2",
            "C. 2028 APRIL 2",
            "D. 2028 APRIL 30",
            "E. 2028 MAY 2",
            "F. The code does not compile.",
            "G. A runtime exception is thrown."
        ],
        "answer": [
            "A"
        ],
        "explanation": "The date starts out as April 30, 2025. Since dates are immutable and the plus methods’ return values are ignored, the result is unchanged. Therefore, option A is correct."
    },
    {
        "question": "What is the output of the following?",
        "code": "var result = LocalDate.of(2025, Month.OCTOBER, 31)\n.plusYears(1)\n.plusMonths(-5)\n.plusMonths(1).withYear(2026)\n.atTime(LocalTime.of(13, 4));\nSystem.out.println(result);",
        "options": [
            "A. 2025-06-30T13:04",
            "B. 2026-04-30",
            "C. 2026-04-30T13:04",
            "D. 2026-06-30",
            "E. 2026-06-30T13:04",
            "F. The code does not compile.",
            "G. A runtime exception is thrown."
        ],
        "answer": [
            "E"
        ],
        "explanation": "The code first creates a date of 2025-10-31. The chaining in the output is valid resulting in interim states of 2026-10-31, followed by 2026-05-31, then 2026-06-30, then 2026-06-30, and finally the result of 2026-06-30T13:04."
    },
    {
        "question": "Which of the following fill in the blank to print a positive integer? (Choose all that apply.)",
        "code": "String[] s1 = { \"Camel\", \"Peacock\", \"Llama\"};\nString[] s2 = { \"Camel\", \"Llama\", \"Peacock\"};\nString[] s3 = { \"Camel\"};\nString[] s4 = { \"Camel\", null};\nSystem.out.println(Arrays.____________________________);",
        "options": [
            "A. compare(s1, s2)",
            "B. mismatch(s1, s2)",
            "C. compare(s3, s4)",
            "D. mismatch(s3, s4)",
            "E. compare(s4, s4)",
            "F. mismatch(s4, s4)"
        ],
        "answer": [
            "A",
            "B",
            "D"
        ],
        "explanation": "The compare() method returns a positive integer when the arrays are different and the first is larger. This is the case for option A since the s2 element at index 1 comes first alphabetically. It is not the case for option C because the s4 is longer or for option E because the arrays are the same. The mismatch() method returns a positive integer when the arrays are different in a position index 1 or greater. This is the case for options B and D since the difference is at index 1. It is not the case for option F because there is no difference."
    },
    {
        "question": "Note that March 12, 2028 is the weekend that clocks spring ahead for daylight saving time. What is the output of the following? (Choose all that apply.)",
        "code": "var date = LocalDate.of(2028, Month.MARCH, 12);\nvar time = LocalTime.of(1, 30);\nvar zone = ZoneId.of(\"US/Eastern\");\nvar dateTime1 = ZonedDateTime.of(date, time, zone);\nvar dateTime2 = dateTime1.plus(1, ChronoUnit.HOURS);\nlong diff = ChronoUnit.HOURS.between(dateTime1, dateTime2);\nint hour = dateTime2.getHour();\nboolean offset = dateTime1.getOffset() == dateTime2.getOffset();\nSystem.out.println(\"diff = \" + diff);\nSystem.out.println(\"hour = \" + hour);\nSystem.out.println(\"offset = \" + offset);",
        "options": [
            "A. diff = 1",
            "B. diff = 2",
            "C. hour = 2",
            "D. hour = 3",
            "E. offset = true",
            "F. The code does not compile.",
            "G. A runtime exception is thrown."
        ],
        "answer": [
            "A",
            "D"
        ],
        "explanation": "The dateTime1 object has a time of 1:30 per initialization. The dateTime2 object is an hour later. However, there is no 2:30 when springing ahead, setting the time to 3:30. Option A is correct because it is an hour later. Option D is also correct because the hour of the new time is 3. Option E is not correct because we have changed the time zone offset due to daylight saving time."
    },
    {
        "question": "Which of the following can fill in the blank to print avaJ? (Choose all that apply.)",
        "code": "var puzzle = new StringBuilder(\"Java\");\npuzzle._________________________;\nSystem.out.println(puzzle);",
        "options": [
            "A. reverse()",
            "B. append(\"vaJ$\").substring(0, 4)",
            "C. append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length() - 1)",
            "D. append(\"vaJ$\").delete(0, 3).deleteCharAt(puzzle.length())",
            "E. None of the above"
        ],
        "answer": [
            "A",
            "C"
        ],
        "explanation": "The reverse() method is the easiest way of reversing the characters in a StringBuilder; therefore, option A is correct. In option B, substring() returns a String, which is not stored anywhere. Option C uses method chaining. First, it creates the value \"JavavaJ$\". Then, it removes the first three characters, resulting in \"avaJ$\". Finally, it removes the last character, resulting in \"avaJ\". Option D throws an exception because you cannot delete the character after the last index. Remember that deleteCharAt() uses indexes that are zero-based, and length() counts the number of characters rather than the index."
    }
]