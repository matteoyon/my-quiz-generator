[
  {
    "question": "Which of the following Java operators can be used with boolean variables? (Choose all that apply.)",
    "options": [
      "A. ==",
      "B. +",
      "C. --",
      "D. !",
      "E. %",
      "F. -",
      "G. Cast with (boolean)"
    ],
    "answer": ["A", "D"],
    "explanation": "The == and ! operators can be used with boolean variables. The +, --, %, and - operators are not applicable to boolean variables. Casting with (boolean) is not a valid operation."
  },
  {
    "question": "What data type (or types) will allow the following code snippet to compile? (Choose all that apply.)",
    "code": "byte apples = 5;\nshort oranges = 10;\n____ bananas = apples + oranges;",
    "options": [
      "A. int",
      "B. long",
      "C. boolean",
      "D. double",
      "E. short",
      "F. byte"
    ],
    "answer": ["A", "B", "D"],
    "explanation": "The result of adding a byte and a short is an int, so the variable bananas must be of type int, long, or double to compile. The types boolean, short, and byte are not valid."
  },
  {
    "question": "What change, when applied independently, would allow the following code snippet to compile? (Choose all that apply.)",
    "code": "3: long ear = 10;\n4: int hearing = 2 * ear;",
    "options": [
      "A. No change; it compiles as is.",
      "B. Cast ear on line 4 to int.",
      "C. Change the data type of ear on line 3 to short.",
      "D. Cast 2 * ear on line 4 to int.",
      "E. Change the data type of hearing on line 4 to short.",
      "F. Change the data type of hearing on line 4 to long."
    ],
    "answer": ["B", "D", "F"],
    "explanation": "The code does not compile as is because the result of 2 * ear is a long, which cannot be assigned to an int without casting. Casting ear or 2 * ear to int, or changing the data type of hearing to long, will allow the code to compile."
  },
  {
    "question": "What is the output of the following code snippet?",
    "code": "3: boolean canine = true, wolf = true;\n4: int teeth = 20;\n5: canine = (teeth != 10) ^ (wolf=false);\n6: System.out.println(canine+\", \"+teeth+\", \"+wolf);",
    "options": [
      "A. true, 20, true",
      "B. true, 20, false",
      "C. false, 10, true",
      "D. false, 20, false",
      "E. The code will not compile because of line 5.",
      "F. None of the above."
    ],
    "answer": ["D"],
    "explanation": "The expression (teeth != 10) evaluates to true, and (wolf=false) evaluates to false. The ^ operator is the logical XOR, so true ^ false is true. Therefore, canine is set to true. The output is false, 20, false."
  },
  {
    "question": "Which of the following operators are ranked in increasing or the same order of precedence? Assume the + operator is binary addition, not the unary form. (Choose all that apply.)",
    "options": [
      "A. +, *, %, --",
      "B. ++, (int), *",
      "C. =, ==, !",
      "D. (short), =, !, *",
      "E. *, /, %, +, ==",
      "F. !, ||, &",
      "G. ^, +, =, +="
    ],
    "answer": ["B", "E", "F"],
    "explanation": "The operators in option B (++ has higher precedence than (int), which has higher precedence than *), option E (*, /, and % have the same precedence, which is higher than +, which is higher than ==), and option F (! has higher precedence than ||, which has higher precedence than &)."
  },
  {
    "question": "What is the output of the following program?",
    "code": "1: public class CandyCounter {\n2: static long addCandy(double fruit, float vegetables) {\n3: return (int)fruit+vegetables;\n4: }\n5: public static void main(String[] args) {\n6: System.out.print(addCandy(1.4, 2.4f) + \", \");\n7: System.out.print(addCandy(1.9, (float)4) + \", \");\n8: System.out.print(addCandy((long)(int)(short)2, (float)4));\n9: } }",
    "options": [
      "A. 4, 6, 6.0",
      "B. 3, 5, 6",
      "C. 3, 6, 6",
      "D. 4, 5, 6",
      "E. The code does not compile because of line 9.",
      "F. None of the above."
    ],
    "answer": ["D"],
    "explanation": "The method addCandy casts the double fruit to an int and adds it to the float vegetables. The results are (int)1.4 + 2.4f = 1 + 2.4f = 3.4f, which is cast to long as 3, (int)1.9 + 4 = 1 + 4 = 5, and (int)2 + 4 = 2 + 4 = 6. Therefore, the output is 4, 5, 6."
  },
  {
    "question": "What is the output of the following code snippet?",
    "code": "int ph = 7, vis = 2;\nboolean clear = vis > 1 & (vis < 9 || ph < 2);\nboolean safe = (vis > 2) && (ph++ > 1);\nboolean tasty = 7 <= --ph;\nSystem.out.println(clear + \"-\" + safe + \"-\" + tasty);",
    "options": [
      "A. true-true-true",
      "B. true-true-false",
      "C. true-false-true",
      "D. true-false-false",
      "E. false-true-true",
      "F. false-true-false",
      "G. false-false-true",
      "H. false-false-false"
    ],
    "answer": ["C"],
    "explanation": "The expression vis > 1 & (vis < 9 || ph < 2) evaluates to true & (true || false) = true & true = true, so clear is true. The expression (vis > 2) && (ph++ > 1) evaluates to false && (7 > 1) = false, so safe is false. The expression 7 <= --ph evaluates to 7 <= 6, which is false, so tasty is false. Therefore, the output is true-false-true."
  },
  {
    "question": "What is the output of the following code snippet?",
    "code": "4: int pig = (short)4;\n5: pig = pig++;\n6: long goat = (int)2;\n7: goat -= 1.0;\n8: System.out.print(pig + \" - \" + goat);",
    "options": [
      "A. 4 - 1",
      "B. 4 - 2",
      "C. 5 - 1",
      "D. 5 - 2",
      "E. The code does not compile due to line 7.",
      "F. None of the above."
    ],
    "answer": ["E"],
    "explanation": "The code does not compile because of line 7. The expression goat -= 1.0 attempts to subtract a double from a long, which is not allowed without casting."
  },
  {
    "question": "What are the unique outputs of the following code snippet? (Choose all that apply.)",
    "code": "int a = 2, b = 4, c = 2;\nSystem.out.println(a > 2 ? --c : b++);\nSystem.out.println(b = (a != c ? a : b++));\nSystem.out.println(a > b ? b < c ? b : 2 : 1);",
    "options": [
      "A. 1",
      "B. 2",
      "C. 3",
      "D. 4",
      "E. 5",
      "F. 6",
      "G. The code does not compile."
    ],
    "answer": ["B", "D"],
    "explanation": "The first expression (a > 2 ? --c : b++) evaluates to 2 > 2 ? --c : b++, which is false, so b++ is executed, and b is incremented to 5. The second expression (b = (a != c ? a : b++)) evaluates to b = (2 != 2 ? a : b++), which is false, so b++ is executed, and b is incremented to 6. The third expression (a > b ? b < c ? b : 2 : 1) evaluates to 2 > 6 ? b < 2 ? b : 2 : 1, which is false, so 1 is returned. Therefore, the unique outputs are 2 and 4."
  },
  {
    "question": "Which is not an output of the following code snippet?",
    "code": "short height = 1, weight = 3;\nshort zebra = (byte) weight * (byte) height;\ndouble ox = 1 + height * 2 + weight;\nlong giraffe = 1 + 9 % height + 1;\nSystem.out.println(zebra);\nSystem.out.println(ox);\nSystem.out.println(giraffe);",
    "options": [
      "A. 2",
      "B. 3",
      "C. 6",
      "D. 6.0",
      "E. The code does not compile."
    ],
    "answer": ["C"],
    "explanation": "The expression (byte) weight * (byte) height evaluates to 3 * 1 = 3, so zebra is 3. The expression 1 + height * 2 + weight evaluates to 1 + 1 * 2 + 3 = 1 + 2 + 3 = 6.0, so ox is 6.0. The expression 1 + 9 % height + 1 evaluates to 1 + 9 % 1 + 1 = 1 + 0 + 1 = 2, so giraffe is 2. Therefore, the output 6 is not produced."
  },
  {
    "question": "What is the output of the following code?",
    "code": "11: int sample1 = (2 * 4) % 3;\n12: int sample2 = 3 * 2 % -3;\n13: int sample3 = 5 * (1 % 2);\n14: System.out.println(sample1 + \", \" + sample2 + \", \" + sample3);",
    "options": [
      "A. 0, 0, 5",
      "B. 1, 2, 10",
      "C. 2, 1, 5",
      "D. 2, 0, 5",
      "E. 3, 1, 10",
      "F. 3, 2, 6",
      "G. The code does not compile."
    ],
    "answer": ["D"],
    "explanation": "The expression (2 * 4) % 3 evaluates to 8 % 3 = 2, so sample1 is 2. The expression 3 * 2 % -3 evaluates to 6 % -3 = 0, so sample2 is 0. The expression 5 * (1 % 2) evaluates to 5 * 1 = 5, so sample3 is 5. Therefore, the output is 2, 0, 5."
  },
  {
    "question": "The _________ operator increases a value and returns the original value, while the _______ operator decreases a value and returns the new value.",
    "options": [
      "A. post-increment, post-increment",
      "B. pre-decrement, post-decrement",
      "C. post-increment, post-decrement",
      "D. post-increment, pre-decrement",
      "E. pre-increment, pre-decrement",
      "F. pre-increment, post-decrement"
    ],
    "answer": ["C"],
    "explanation": "The post-increment operator (i++) increases a value and returns the original value, while the post-decrement operator (i--) decreases a value and returns the new value."
  },
  {
    "question": "What is the output of the following code snippet?",
    "code": "boolean sunny = true, raining = false, sunday = true;\nboolean goingToTheStore = sunny & raining ^ sunday;\nboolean goingToTheZoo = sunday && !raining;\nboolean stayingHome = !(goingToTheStore && goingToTheZoo);\nSystem.out.println(goingToTheStore + \"-\" + goingToTheZoo + \"-\" +stayingHome);",
    "options": [
      "A. true-false-false",
      "B. false-true-false",
      "C. true-true-true",
      "D. false-true-true",
      "E. false-false-false",
      "F. true-true-false",
      "G. None of the above"
    ],
    "answer": ["D"],
    "explanation": "The expression sunny & raining ^ sunday evaluates to true & false ^ true = false ^ true = true, so goingToTheStore is true. The expression sunday && !raining evaluates to true && true = true, so goingToTheZoo is true. The expression !(goingToTheStore && goingToTheZoo) evaluates to !(true && true) = !(true) = false, so stayingHome is false. Therefore, the output is true-true-false."
  },
  {
    "question": "Which of the following statements are correct? (Choose all that apply.)",
    "options": [
      "A. The return value of an assignment operation expression can be void.",
      "B. The inequality operator (!=) can be used to compare objects.",
      "C. The equality operator (==) can be used to compare a boolean value with a numeric value.",
      "D. During runtime, the & and | operators may cause only the left side of the expression to be evaluated.",
      "E. The return value of an assignment operation expression is the value of the newly assigned variable.",
      "F. In Java, 0 and false may be used interchangeably.",
      "G. The logical complement operator (!) cannot be used to flip numeric values."
    ],
    "answer": ["B", "E", "G"],
    "explanation": "The inequality operator (!=) can be used to compare objects. The return value of an assignment operation expression is the value of the newly assigned variable. The logical complement operator (!) cannot be used to flip numeric values. Option A is incorrect because the return value of an assignment operation expression cannot be void. Option C is incorrect because the equality operator (==) cannot be used to compare a boolean value with a numeric value. Option D is incorrect because the & and | operators always evaluate both sides of the expression. Option F is incorrect because in Java, 0 and false cannot be used interchangeably."
  },
  {
    "question": "Which operator takes three operands or values?",
    "options": [
      "A. =",
      "B. &&",
      "C. *=",
      "D. ? :",
      "E. &",
      "F. ++",
      "G. /"
    ],
    "answer": ["D"],
    "explanation": "The ternary operator ( ? : ) takes three operands or values."
  },
  {
    "question": "How many lines of the following code contain compiler errors?",
    "code": "int note = 1 * 2 + (long)3;\nshort melody = (byte)(double)(note *= 2);\ndouble song = melody;\nfloat symphony = (float)((song == 1_000f) ? song * 2L : song);",
    "options": [
      "A. 0",
      "B. 1",
      "C. 2",
      "D. 3",
      "E. 4"
    ],
    "answer": ["A"],
    "explanation": "There are no compiler errors in the code. All lines compile successfully."
  },
  {
    "question": "Given the following code snippet, what are the values of the variables after it is executed? (Choose all that apply.)",
    "code": "int ticketsTaken = 1;\nint ticketsSold = 3;\nticketsSold += 1 + ticketsTaken++;\nticketsTaken *= 2;\nticketsSold += (long)1;",
    "options": [
      "A. ticketsSold is 8.",
      "B. ticketsTaken is 2.",
      "C. ticketsSold is 6.",
      "D. ticketsTaken is 6.",
      "E. ticketsSold is 7.",
      "F. ticketsTaken is 4.",
      "G. The code does not compile."
    ],
    "answer": ["E", "F"],
    "explanation": "After the code is executed, ticketsSold is 7 and ticketsTaken is 4. The expression ticketsSold += 1 + ticketsTaken++ evaluates to ticketsSold += 1 + 1, so ticketsSold becomes 5 and ticketsTaken becomes 2. The expression ticketsTaken *= 2 evaluates to ticketsTaken = 2 * 2, so ticketsTaken becomes 4. The expression ticketsSold += (long)1 evaluates to ticketsSold = 5 + 1, so ticketsSold becomes 6."
  },
  {
    "question": "Which of the following can be used to change the order of operation in an expression?",
    "options": [
      "A. [ ]",
      "B. < >",
      "C. ( )",
      "D. \\ /",
      "E. { }",
      "F. \" \""
    ],
    "answer": ["C"],
    "explanation": "Parentheses ( ) can be used to change the order of operation in an expression."
  },
  {
    "question": "What is the result of executing the following code snippet? (Choose all that apply.)",
    "code": "3: int start = 7;\n4: int end = 4;\n5: end += ++start;\n6: start = (byte)(Byte.MAX_VALUE + 1);",
    "options": [
      "A. start is 0.",
      "B. start is -128.",
      "C. start is 127.",
      "D. end is 8.",
      "E. end is 11.",
      "F. end is 12.",
      "G. The code does not compile.",
      "H. The code compiles but throws an exception at runtime."
    ],
    "answer": ["B", "E"],
    "explanation": "The expression end += ++start evaluates to end = 4 + 8, so end becomes 12. The expression start = (byte)(Byte.MAX_VALUE + 1) evaluates to start = (byte)(127 + 1), which is -128 due to overflow. Therefore, start is -128 and end is 12."
  },
  {
    "question": "Which of the following statements about unary operators are true? (Choose all that apply.)",
    "options": [
      "A. Unary operators are always executed before any surrounding numeric binary or ternary operators.",
      "B. The - operator can be used to flip a boolean value.",
      "C. The pre-increment operator (++) returns the value of the variable before the increment is applied.",
      "D. The post-decrement operator (--) returns the value of the variable before the decrement is applied.",
      "E. The ! operator cannot be used on numeric values.",
      "F. None of the above."
    ],
    "answer": ["A", "E"],
    "explanation": "Unary operators are always executed before any surrounding numeric binary or ternary operators. The ! operator cannot be used on numeric values. Option B is incorrect because the - operator cannot be used to flip a boolean value. Option C is incorrect because the pre-increment operator (++) returns the value of the variable after the increment is applied. Option D is incorrect because the post-decrement operator (--) returns the value of the variable after the decrement is applied."
  }
]